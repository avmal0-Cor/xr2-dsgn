/*
<HELP>
Pelt Tools
AUTHOR: Sunit Parekh
DATE:	13.12.05
VERSION:1.01

DESCRIPTION: 	Creates a spring based "pelting" simulation

SHELF BUTTON:	source peltingTools.mel;
		peltingToolsSetup;

USAGE:		source peltingTools.mel;
		peltingTools;

		
HELP:		some functions need the closestPointOnMesh plugins
		
		1) select object and enter name into name field;
		2) select edges and "Cut" for seam (pay close attention to hands and feet)
		3) click "Add continuous Edges" to add edges to your list
		5) "Create Pelting Frame" - you can manipulate this frame to make other shapes
			a) use the radio buttons to align to the correct axis
			b) scale your frame to fit the shape you want.  by default the frame tries to 
			match your object bounding box.
			
		6) set presets for frameStrength, meshStrength, and wireframe walkLength
			a) these can also be changed later

		7) PELT
			a) You may need to flip the "Frame" in X or in Z for the springs to look like right.
			   Right-Click the framename  (under "Create Pelting Frame") and you can flip the curve.

		8) run simulation
			a) use mesh strength and frame strength to settle pelt
			b) you may also need to use RUNTIME VELOCITY to lower the speed
				i) CTRL+MMB drag in the field changes the values 
		
		9) view visualisations
			a) open the visualisation tools frame 
				i) if an image isn't already displayed, click on the icon to load one
			b) turn on "checkered" view, or toggle between a baked normals and normal version of your
			mesh.
			c) the textured view runs at a slower rate than the untextured
			d) use the repeat uv fields to change the 2d placement node repeat uv
		
		10) when you're happy with the sim, hit REMOVE PELT FROM SIM
			a) this will project a planar uv map onto this mesh and unhide the original
			b) the uv's are automatically transferred to the original mesh
	
----------------------------------------------------------------------------------------------------------
		
		TIPS: 	Remember to increase your time range to something like 5000 or 10000 frames.
	
			Using a "walklength" greater than 1 will help to decrease shearing in your uv map
			
		TROUBLESHOOTING:
				"SPRINGS OUT OF CONTROL!"
				1) If your springs move slowly, increase the frame spring strength.  Right now, the pelting
				default is independent of the size of your model, and on different scale models you may have 
				different settings.
			
				2) If your springs go out of control - lower the mesh strength.
								
				"PELT DISTORTS MY UV'S TOO MUCH!"
				4) If you're finding a lot of shearing in your uv's, then try increasing the walklength
				to 2.  remember this triples the initial calculation times for the pelting.  you can also try local
				spring vertices
				
		NOTES:		You can have multiple "peltingGroups" at the same time.  the UI items all dynamically set
				based on your "group" selection.
				

	
Version History
1.01  -	Added many speed optimisations.  Fixed Remove peltGroup button.  Edge list now stored as vtx list.  Timers added to 
	compare speed.  Fixed "add" button in peltGroup.  Added "normalize within current range" button.  Added tablayouts.
	Added API.  Removed some confirmDialog prompts.
1.0RC2- Fixed Texture assignment.  Also added some checks for high walkLengths.  Added Script Job.  Added controls to add 
	extra springs.
1.0RC1-	Changed some UI options.  Pelt groups have individual shaders.  Shader is assigned to original at remove.
	normalsMesh is part of the peltingMesh (polyNormalPerVertex node).  Renamed parts components.  peltingToolsSetup 
	now exists.  Baked normals now work for parts based pelting.  New cut mesh at uv seams
0.22a-	Fixed parts pelting slowdown.  Added new frame particle algorithm.
0.22 -	LAST BETA - Major Changes: Parts based pelting incorporated (as parts element sets).  Direct link now between
	pelt and original, uncut model.  Added Utilities menu for non-pelt related features.  Visibility options for
	pelt groups.  More confirmDialogs prompting actions upon remove, delete, etc.  "Lock Pelt" toggle - allows user
	stop simulation and still scrub in the time range.  useful when you want to compare many different pelts, but still 
	maintain their pelt attachments.
0.21a-	Incremental Update - changes UI elements and backend.
0.21 -	Fixed Checker Texture Bug.  Added confirm dialog to Transfer Feature.  Added workaround for removeSimPelt bug.
	Fixed memory leak in transfer UV.  Fixed transfer UV bugs.  startVtx, midVtx optional.  Sliders for controls.
	Changed stiffness defaults.
0.20 -	Added UV transfer between objects with different vertex orders.  Fixed Help Display.  
	Fixed removeSimPelt bug.  Added Utilities Menu
0.19 -	Added Baked Normals display.  Merge Edge is now also more reliable.
0.18 -	Added vertex coloring of edges.  Blue for "Cut," remove color for "Merge" and Red for "Continuous"
	Added edge display options (global override, local toggle) 
	changed endVtx to midVtx
0.17 -	Rehauled entire UI and most of the basic organization.  now much easier to manage multiple pelts.
	fixed undo errors
0.15 -	Added confirm prompt for store replace
0.14 -	Added a new visualisation frame with dynamically updating texture views

0.11 -	Fixed some reSpring bugs, and some orientation bugs
	Fine-tuned undoInfo a bit better - now possible to undo "pelt" without extra nodes

0.10 -	Frame can be from any axis
	changed undo queue method so that the queue isn't accidentally left off
	changed pole method (relies on both end and start vertices now)
	double check for start and end so that they can only be selected from the edge list

0.09 -	changed undo queue with cutting
	added some pelting preset controls
	
0.07 -	first version

<HELP>
*/



/// /////////////////////////////////////////////////////////////////////////// ///
///										///
///	Open Maya Toolbox: Opensource Alias Maya toolbox			///
///	Copyright (C) 2005 OMToolbox community					///
///										///
///	This library is free software; you can redistribute it and/or modify it ///
///	under the terms of the GNU Lesser General Public License as published 	///
///	by the Free Software Foundation; either version 2.1 of the License, or 	///
///	(at your option) any later version.					///
///										///
///	This library is distributed in the hope that it will be useful, but 	///
///	WITHOUT ANY WARRANTY; without even the implied warranty of 		///
///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 		///
///	GNU Lesser General Public License for more details.			///
///										///
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///				SCRIPT START					///
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	string and array		 			///
///	Output: 	returns 1 if string occurs in array, 0 if not	 	///
///////////////////////////////////////////////////////////////////////////////////

proc int pt_OM_inArray( string $string , string $array[])
{
	int	$int;
	int 	$return = 0;
	
	for ($int = 0 ; $int < size($array) ; $int++)
	{
	   if ( $string == $array[$int] ) {$return = 1;}
	}
	return $return;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 					 			///
///	Output: 							 	///
///////////////////////////////////////////////////////////////////////////////////

proc int pt_OM_adjacentFaces( string $edge)
{
	int	$int;
	int 	$return = 0;
	
	string	$token[];
	string	$dump[];
	
	$token = `polyInfo -ef $edge`;
	tokenize ($token[0], $dump);

	return (size($dump)-2);
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	2 arrays			 			///
///	Output: 	adds the second array at the end of the first 		///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_addStringArray(string $origArray[] , string $addArray[])
{
	int	$int;

	for ($int = 0 ; $int < size($addArray) ; $int++)
	{
	   $origArray[ size($origArray) ] = $addArray[$int];
	}
	return $origArray;
}

///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	a component name	 				///
///	Output: 	returns 1 if the indput name has a number and 0 if	/// 
///			it hasn't						///
///////////////////////////////////////////////////////////////////////////////////

proc int pt_OM_haveIndex(string $indput)
{
	string	$dump[];
	
	int $size = `tokenize $indput "[]" $dump`;
	
	int $return = 0;
	
	if ($size == 2)
	{
	   $return = 1;
	}
	
	return $return;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	2 arrays		 				///
///	Output: 	returns an array with the first array turned backwards	///
///			and combined with the second			 	///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_combineStringArray(string $backwardArray[] , string $forwardArray[])
{
	int	$int;
	string 	$return[];
	
	for ($int = (size($backwardArray)-1) ; $int >= 0 ; $int--)
	{
	   $return[(size($return))] = $backwardArray[$int];
	}
	for ($int = 1 ; $int <= (size($forwardArray)-1) ; $int++)
	{
	   $return[(size($return))] = $forwardArray[$int];	
	}
	
	return $return;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Indput selection	 				///
///	Output: 	String: Object name			 		///
///////////////////////////////////////////////////////////////////////////////////

proc string pt_OM_objectName(string $objSelection)
{
	string	$name[];
	
	tokenize $objSelection "." $name;
	
	return $name[0];
}

///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Arrays							///
///	Output: 	String array with every component occurs more then once	///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_stringArrayGetDuplicates(string $array[])
{
	
	string $return[];
	
	int	$int1;
	int	$int2;
	
	for ($int1 = 0 ; $int1 < size($array) ; $int1++)
	{
	    for ($int2 = 1 ; $int2 < size($array) ; $int2++)
	    {
	    	if ($int1 == $int2) continue;
	    	else if ($array[$int1] == $array[$int2]) $return[size($return)] = $array[$int1];  	
	    }		
	}
	
    	return $return;
    
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Edge			 				///
///	Output: 	returns an array with the two vertices adjacent to 	///
///			input edge						///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_edge2vtx(string $edge)
{
	string	$dump[];
	string 	$token[];
	string 	$object = `pt_OM_objectName($edge)`;
	string 	$return[];
	
	$token = `polyInfo -ev $edge`;
	tokenize ($token[0], $dump);
	
	$return[0] = $object + ".vtx[" + $dump[2] + "]";
	$return[1] = $object + ".vtx[" + $dump[3] + "]";
	
	return $return;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	a vertex 						///
///	Output: 	returns 1 if the vertex's a quad and 0 if it isn't	///
///////////////////////////////////////////////////////////////////////////////////

proc int pt_OM_isVtxQuad(string $vtx )
{

	string 	$token[];
	string	$dump[];

	int $result = 0;
	
	if( pt_OM_haveIndex($vtx) == 1 )
	{
	   $token = `polyInfo -ve $vtx`;
	   tokenize ($token[0], $dump);	

	   if (size($dump) == 6 )
	   { 
		$result = 1;
	   }
	}
	
	return $result;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Edge plus a quad vertex adjacent to the edge.		///
///	Output: 	string array, where [0] is the edge on the opposite side///
///			of the vertex and [1] is the new vertex adjacent to the ///
///			new edge, where the vtx isn't similar to the input 	///
///			vertex							///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_OppEdgeOnVtx(string $edge, string $quadVtx)
{

	string 	$token[];
	string	$dump[];
	string 	$return[];
	string 	$object = `pt_OM_objectName($edge)`;
	int	$int;
	
	$token = `polyInfo -ve $quadVtx`;
	tokenize ($token[0], $dump);
	
	for ($int = 2 ; $int <= 5 ; $int++)
	{
	   
	   if( ($object + ".e[" + $dump[$int] + "]") == $edge)
	   {
		if ($int == 2 || $int == 3) 
		{
		   $return[0] = ($object + ".e[" + $dump[($int+2)] + "]"); 
		}
		else $return[0] = ($object + ".e[" + $dump[($int-2)] + "]");
	   }	
	}

	$token = `polyInfo -ev $return[0]`;
	tokenize ($token[0], $dump);
	
	if (($object + ".vtx[" + $dump[2] + "]") == $quadVtx)
	{
		$return[1] = $object + ".vtx[" + $dump[3] + "]";
	}
	else	
	{
		$return[1] = $object + ".vtx[" + $dump[2] + "]";
	}
	
	return $return;
	
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	a vertex 						///
///	Output: 	returns 1 if the vertex's a tris and 0 if it isn't	///
///////////////////////////////////////////////////////////////////////////////////

proc int pt_OM_isVtxTris(string $vtx )
{

	string 	$token[];
	string	$dump[];

	int $result = 0;
	
	if( pt_OM_haveIndex($vtx) == 1 )
	{
	   $token = `polyInfo -ve $vtx`;
	   tokenize ($token[0], $dump);	

	   if (size($dump) == 5 )
	   { 
		$result = 1;
	   }
	}
	
	return $result;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Edge plus a tris vertex adjacent to the edge.		///
///	Output: 	string array, where [0] is the edge on the opposite side///
///			of the face and [1] is the new vertex adjacent to the 	///
///			new edge, 						///
///			where the vertex isn't similar to the input vertex	///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_OppEdgeOnBorder(string $edge, string $trisVtx)
{

	string 	$token[];
	string	$dump[];
	string	$e2f[];
	string 	$return[];
	string 	$object = `pt_OM_objectName($edge)`;
	
	$token = `polyInfo -ve $trisVtx`;
	tokenize ($token[0], $dump);
	
	for ($int = 2 ; $int <= 4 ; $int++)
	{
	   $token = `polyInfo -ef ($object + ".e[" + $dump[$int] + "]")`;
	   tokenize ($token[0], $e2f);
	   
	   if ( size($e2f) == 3 && ($object + ".e[" + $dump[$int] + "]") != $edge)
	   {
	   	$return[0] = ($object + ".e[" + $dump[$int] + "]");
	   }
	} 
		
	$token = `polyInfo -ev $return[0]`;
	tokenize ($token[0], $dump);
	
	if (($object + ".vtx[" + $dump[2] + "]") == $trisVtx)
	{
		$return[1] = $object + ".vtx[" + $dump[3] + "]";
	}
	else	
	{
		$return[1] = $object + ".vtx[" + $dump[2] + "]";
	}
	
	return $return;
	
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Edge			 				///
///	Output: 	returns a string Array with the two faces adjacent 	///
///			to the input edge					///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_edge2face(string $edge)
{
	string	$dump[];
	string 	$token[];
	string 	$object = `pt_OM_objectName($edge)`;
	string $return[];
	
	$token = `polyInfo -ef $edge`;
	tokenize ($token[0], $dump);
	
	$return[0] = $object + ".f[" + $dump[2] + "]";
	$return[1] = $object + ".f[" + $dump[3] + "]";
	
	return $return;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	a face 							///
///	Output: 	returns 1 if the face's a quad and 0 if it isn't	///
///////////////////////////////////////////////////////////////////////////////////

proc int pt_OM_isFaceQuad(string $face )
{

	string 	$token[];
	string	$dump[];

	int $result = 0;
	
	if( pt_OM_haveIndex($face) == 1 )
	{
	   $token = `polyInfo -fe $face`;
	   tokenize ($token[0], $dump);	

	   if (size($dump) == 6 )
	   { 
		$result = 1;
	   }
	}
	
	return $result;
}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Edge plus a quad face adjacent to the edge.		///
///	Output: 	string array, where [0] is the edge on the opposite side///
///			of the face and [1] is the new face adjacent to the new	///
///			edge, where the face isn't similar to the input face	///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_OppEdgeOnFace(string $edge, string $quadFace)
{

	string 	$token[];
	string	$dump[];
	string 	$return[];
	string 	$object = `pt_OM_objectName($edge)`;
	
	$token = `polyInfo -fe $quadFace`;
	tokenize ($token[0], $dump);
	
	for ($int = 2 ; $int <= 5 ; $int++)
	{
	   if( (pt_OM_objectName($edge) + ".e[" + $dump[$int] + "]") == $edge)
	   {
		if ($int == 2 || $int == 3) 
		{
		   $return[0] = ($object + ".e[" + $dump[($int+2)] + "]"); 
		}
		else $return[0] = ($object + ".e[" + $dump[($int-2)] + "]");
	   }	
	}

	$token = `polyInfo -ef $return[0]`;
	tokenize ($token[0], $dump);
	
	if (($object + ".f[" + $dump[2] + "]") == $quadFace)
	{
		$return[1] = $object + ".f[" + $dump[3] + "]";
	}
	else	
	{
		$return[1] = $object + ".f[" + $dump[2] + "]";
	}
	
	return $return;
	
}

///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Edge and edge array					///
///	Output: 	String array with loopedges.				///
///			If only one edge appear on the loop it returns a whole	///
///			loop.							///
///			If a element in $selection is detected on the loop it 	///
///			only selects a partial loop between input and the 	///
///			$selection element					///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_listLoop(string $edge1, string $selection[])
{

	global string $partials[];
	
	string	$dump[];
	string 	$token[];
	string	$split1[];
	string	$split2[];
	string	$vtx[];
	string	$return[];
	int	$stop;
	int	$partialBool = 0;
	int 	$stoppedSplit;
	int	$int;
	int	$intVtx0;
	int	$intVtx1;
	

	$split1[0] = $edge1;
	$split2[0] = $edge1; 
	
	$vtx = pt_OM_edge2vtx($edge1);
	$int = pt_OM_isVtxQuad($vtx[0]);
	
	if ($int == 0)
	{
	   if (pt_OM_isVtxQuad($vtx[1]))
	   {
		   $edgeNvtx[1] = $vtx[1];
		   do
		   {
		   	$stop = 0;
			$edgeNvtx = pt_OM_OppEdgeOnVtx($split2[(size($split2) -1)], $edgeNvtx[1]);
			$split2[size($split2)] = $edgeNvtx[0];
			
		   	if ( $edgeNvtx[0] == $edge1) 
		   	{
		   	   $stop = 1;
		   	}
		   	else if (pt_OM_inArray($edgeNvtx[0], $selection) == 1)
		   	{
		   	   $partialBool = 1;
		   	   $partials[size($partials)] = $edgeNvtx[0];
		   	   $stop = 1;
		   	}
		   } 
		   while (pt_OM_isVtxQuad($edgeNvtx[1]) == 1 && $stop == 0);
	   }
 	   else if (pt_OM_adjacentFaces($edge1) == 1)
	   {	
	      $intVtx0 = pt_OM_isVtxTris($vtx[0]);
	      $intVtx1 = pt_OM_isVtxTris($vtx[1]);
	
	      if ( $intVtx0 == 1 || $intVtx1 == 1 )
	      {
		switch ( $intVtx0 ) 
		{
	   	   case 1:
			$edgeNvtx[1] = $vtx[0];		
			do
			{
			   $stop = 0;
			   $edgeNvtx = (pt_OM_OppEdgeOnBorder( $split1[ (size($split1)-1) ] , $edgeNvtx[1] ));
			   $split1[ size($split1) ] = $edgeNvtx[0];
			
			   if ($edgeNvtx[0] == $edge1) 
			   {
			   	$stop = 1;
			   }
			   else if (pt_OM_inArray($edgeNvtx[0], $selection) == 1 )
			   {
			   	$partialBool = 1;
			   	$partials[size($partials)] = $edgeNvtx[0];
			   	$stop = 1;
			   }			   
			} 
			while (pt_OM_isVtxTris($edgeNvtx[1]) == 1 && $stop == 0);
		
			if ($stop == 1) break;
			
	   	   case 0:
			if (pt_OM_isVtxTris($vtx[1]))
			{
			   $edgeNvtx[1] = $vtx[1];
			   do
			   {
			   	$stop = 0;
				$edgeNvtx = pt_OM_OppEdgeOnBorder($split2[(size($split2) -1)], $edgeNvtx[1]);
				$split2[size($split2)] = $edgeNvtx[0];
			
			   	if ($edgeNvtx[0] == $edge1) 
			   	{
			   	   $stop = 1;
			   	}
			   	else if (pt_OM_inArray($edgeNvtx[0], $selection) == 1 )
			   	{
			   	   $partialBool = 1;
			   	   $partials[size($partials)] = $edgeNvtx[0];
			   	   $stop = 1;
			   	}
			   } 
			   while (pt_OM_isVtxTris($edgeNvtx[1]) == 1 && $stop == 0);
			}

		
		}
	     }
	   }
	   else warning "This is not a loopEdge";
	}
	
	
	else
	{
			
	switch ( $int ) 
	{
	   case 1:
	   
		$edgeNvtx[1] = $vtx[0];	
		$stoppedSplit = 1;	
		do
		{
		   $stop = 0;
		   $edgeNvtx = (pt_OM_OppEdgeOnVtx( $split1[ (size($split1)-1) ] , $edgeNvtx[1] ));
		   $split1[ size($split1) ] = $edgeNvtx[0];
		   
		   if ( $split1[ (size($split1)-1) ] == $edge1) 
		   {
		   	$stop = 1;
		   }
		   else if (pt_OM_inArray($edgeNvtx[0], $selection) == 1)
		   {
		   	$stoppedSplit = 0;
		   	$partialBool = 1;
		   	$partials[size($partials)] = $edgeNvtx[0];
		   	$stop = 1;
		   }
		} 
		while (pt_OM_isVtxQuad($edgeNvtx[1]) == 1 && $stop == 0);
		if ($edgeNvtx[0] == $edge1) break;
		
		
		
				
	   case 0:
		if (pt_OM_isVtxQuad($vtx[1]))
		{
		   $edgeNvtx[1] = $vtx[1];
		   $stoppedSplit = ($stoppedSplit + 2);
		   do
		   {
		   	$stop = 0;
			$edgeNvtx = pt_OM_OppEdgeOnVtx($split2[(size($split2) -1)], $edgeNvtx[1]);
			$split2[size($split2)] = $edgeNvtx[0];
		   				
			if ($edgeNvtx[0] == $edge1)
			{
			   $stop = 1;
			}
		   	else if (pt_OM_inArray( $edgeNvtx[0], $selection) == 1)
		   	{
		   	   $stoppedSplit = ($stoppedSplit - 2);
		   	   $partialBool = 1;
		   	   $partials[ size($partials) ] = $edgeNvtx[0];
		   	   $stop = 1;
		   	}
		   } 
		   while (pt_OM_isVtxQuad($edgeNvtx[1]) == 1 && $stop == 0);
		}

		
	}
	}
	
	
	if ($partialBool == 1)
	{
	   
   	   if (size($split1) == 1) $return = $split2;
	   else if (size($split2)== 1) $return = $split1;
	   else if (size($split1) < size($split2) && $stoppedSplit != 1) $return = $split1;
	   else if (size($split1) < size($split2) && $stoppedSplit == 1) $return = $split2;
	   else if (size($split1) > size($split2) && $stoppedSplit != 2) $return = $split2;
	   else if (size($split1) > size($split2) && $stoppedSplit == 2) $return = $split1;
	   else if (size($split1) == size($split2) && $stoppedSplit != 1) $return = $split1;
	   else if (size($split1) == size($split2) && $stoppedSplit != 2) $return = $split2;
	   
	}
	else $return = pt_OM_combineStringArray($split1 , $split2);

	return $return;
	

}

///////////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////////
///	Indput: 	Edge and edge array					///
///	Output: 	String array with ringedges.				///
///			If only one edge appear on the ring it returns a whole 	///
///			ringloop.						///
///			If a element in $selection is detected on the ring it 	///
///			only selects a partial ring between input and the 	///
///			$selection element					///
///////////////////////////////////////////////////////////////////////////////////

proc string[] pt_OM_listRing(string $edge1, string $selection[])
{

	global string $partials[];
	
	string	$dump[];
	string 	$token[];
	string	$split1[];
	string	$split2[];
	string	$faces[];
	string	$return[];
	int	$stop;
	int	$int;
	int	$stoppedRing;
	int	$partialBool = 0;
	

	$split1[0] = $edge1;
	$split2[0] = $edge1; 

	
	$faces = pt_OM_edge2face($edge1);
	$int = pt_OM_isFaceQuad($faces[0]);
	   
	switch ( $int ) 
	{
	   case 1:
		$edgeNface[1] = $faces[0];
		$stoppedRing = 1;
		do
		{
		   $stop = 0;
		   $edgeNface = (pt_OM_OppEdgeOnFace( $split1[ (size($split1)-1) ] , $edgeNface[1] ));
		   $split1[ size($split1) ] = $edgeNface[0];
			
		   if ($edgeNface[0] == $edge1) 
		   {
		   	$stop = 1;
		   }
		   else if (pt_OM_inArray($edgeNface[0], $selection) == 1) 
		   {	
			$stoppedRing = 0;
			$partialBool = 1;
			$partials[size($partials)] = $edgeNface[0];   
		   	$stop = 1;
		   }
		} 
		while (pt_OM_isFaceQuad($edgeNface[1]) == 1 && $stop == 0);
		if ($edgeNface[0] == $edge1) break;
			
	   case 0:
		if (pt_OM_isFaceQuad($faces[1]))
		{
		   $edgeNface[1] = $faces[1];
		   $stoppedRing = ($stoppedRing + 2);
		   do
		   {
		   	$stop = 0;
			$edgeNface = pt_OM_OppEdgeOnFace($split2[(size($split2) -1)], $edgeNface[1]);
			$split2[size($split2)] = $edgeNface[0];
			
		   	if ($edgeNface[0] == $edge1) 
		   	{
		   	   $stop = 1;
		   	}
		   	else if (pt_OM_inArray($edgeNface[0] , $selection) == 1) 
		   	{
		   	   $stoppedRing = ($stoppedRing - 2);
		   	   $partialBool = 1;
		   	   $partials[size($partials)] = $edgeNface[0];
		   	   $stop = 1;
		   	}
		   } 
		   while (pt_OM_isFaceQuad($edgeNface[1]) == 1 && $stop == 0);
		}

		
	}
	
	if ($partialBool == 1)
	{
   	   if (size($split1) == 1) $return = $split2;
	   else if (size($split2)== 1) $return = $split1;
	   else if (size($split1) < size($split2) && $stoppedRing != 1) $return = $split1;
	   else if (size($split1) < size($split2) && $stoppedRing == 1) $return = $split2;
	   else if (size($split1) > size($split2) && $stoppedRing != 2) $return = $split2;
	   else if (size($split1) > size($split2) && $stoppedRing == 2) $return = $split1;
	   else if (size($split1) == size($split2) && $stoppedRing != 1) $return = $split1;
	   else if (size($split1) == size($split2) && $stoppedRing != 2) $return = $split2;
	   
	}
	else $return = pt_OM_combineStringArray($split1 , $split2);
	
	return $return;

}

///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///					TOOL					///
///	Indput: 	Component Selection	 				///
///	Function: 	LoopSelection on each component. Two or more edges 	///
///			appear on the same loop, it makes a partial selection 	///
///			in stead (provided that selection is edges)		///
///////////////////////////////////////////////////////////////////////////////////

global proc pt_OMT_to_selectLoop()
{
	global string $partials[];
	clear $partials;
	
	string $select[];
	string $listLoop[];
	
	clear $partials;
	
	string 	$selection[];



	//edges
	if (size(`filterExpand -sm 32`) > 0)
	{
	   $selection = `filterExpand -sm 32`;

	   undoInfo -swf 0;
	   for ($sel in $selection)
	   {
	   	if (pt_OM_inArray($sel, $partials) == 1) continue;
	   	$listLoop = pt_OM_listLoop($sel,$selection);
	   	$select = (pt_OM_addStringArray($select, $listLoop ));
	   }
	   undoInfo -swf 1;
	   select -r $select;

	}
	
	
	//vertices
	else if (size(`filterExpand -sm 31`) > 0)
	{
		
	    string	$token[];
	    string	$dump[];
	    string	$edgeList[];
	    int		$int;

	    undoInfo -swf 0;
		
	    $selection = `filterExpand -sm 31`;
	    
	    string 	$object = `pt_OM_objectName($selection[0])`;
	    
	    for ($sel in $selection)
	    {
	    	$token = `polyInfo -ve $sel`;
	    	tokenize ($token[0], $dump);
	    	
	    	for ($int = 2; $int < size($dump) ; $int++)
	    	{
	    	    $edgeList[size($edgeList)] = $dump[$int];	    	    
	    	}
	    }
	    
	    $dump = pt_OM_stringArrayGetDuplicates($edgeList);
	    clear $selection;
	    for ($d in $dump) $selection[size($selection)] = ($object + ".e[" + $d + "]");
	    

	    for ($sel in $selection)
	    {
	   	if (pt_OM_inArray($sel, $partials) == 1) continue;
	   	$listLoop = pt_OM_listLoop($sel,$selection);
	   	$select = (pt_OM_addStringArray($select, $listLoop ));
	    }
	    
	    select -r $select;
	    ConvertSelectionToVertices;
	    $select = `ls -sl`;
	    
	    undoInfo -swf 1;	    
	    
	    select -r $select;
	    
	}
	
	
	
	//faces
	else if (size(`filterExpand -sm 34`) > 0)
	{

	    string	$token[];
	    string	$dump[];
	    string	$edgeList[];
	    int		$int;

	    undoInfo -swf 0;
		
	    $selection = `filterExpand -sm 34`;
	    
	    string 	$object = `pt_OM_objectName($selection[0])`;
	    
	    for ($sel in $selection)
	    {
	    	$token = `polyInfo -fe $sel`;
	    	tokenize ($token[0], $dump);
	    	
	    	for ($int = 2; $int < size($dump) ; $int++)
	    	{
	    	    $edgeList[size($edgeList)] = $dump[$int];	    	    
	    	}
	    }
	    
	    $dump = pt_OM_stringArrayGetDuplicates($edgeList);
	    clear $selection;
	    for ($d in $dump) $selection[size($selection)] = ($object + ".e[" + $d + "]");
	    

	    for ( $sel in $selection )
	    {
	   	if (pt_OM_inArray($sel, $partials) == 1) continue;
	   	$select = (pt_OM_addStringArray($select, ( pt_OM_listRing($sel,$selection) ) ));
	    }
	    
	    select -r $select;
	    ConvertSelectionToFaces;
	    $select = `ls -sl`;
	    
	    undoInfo -swf 1;	    
	    
	    select -r $select;


	}
	else
	{
	    warning "You need some kind of loop-like-selectable selection, which'll be edges, vertices and faces";
	}
	
	
	undoInfo -swf 1;
	
}
///////////////////////////////////////////////////////////////////////////////////






//********************************
//END OF OMTOOLBOX
//********************************





//**************************************************************************
//
//					CUTTING PROC
//
//**************************************************************************
global proc pt_cutEdges(string $type)
{
	//	edges
	//
	string $edges[]=`ls -sl`;

	if (size($edges)>0)
	if(`match ".e[[]" $edges[0]`=="")
		warning "Select Some Edges to Cut!";
	else
		pt_cutEdgesWorking($edges, $type);
}


global proc pt_cutEdgesWorking(string $edges[], string $type)
{
	$start = `timerX`;
	
	//	is this quicker than storing the conversion?
	//
	select(`polyListComponentConversion -fe -tv`);
	string $vtxs[]=`ls -sl`;

	//	add vertex coloring
	//
	if ($type == "pelt")
		pt_addColor("Cut");

	//	get object
	//
	string $obj = `match "^.+[!.]" $vtxs[0]`;
	$obj = `substring $obj 1 (size($obj) -1 )`;
	
	//	turn on display border
	//	
	polyOptions -db true;

	

	//	grow vtx selection
	//
	// select (`polyListComponentConversion -fv -te`);

	//	select original edges
	//
	select ($edges);

	//	de-select border edges and grow at the same time...
	//
	polySelectConstraint -m 2 -pp 1 -w 2 -t 0x8000;
	resetPolySelectConstraint;
	
	//	back to vertices, and remove originals
	//
	select (`polyListComponentConversion -fe -tv`);
	select -tgl $vtxs;
	string $rVtxs[]=`ls -sl`;

	//	split original vtxs
	//
	polySplitVertex $vtxs;
	
	// undoInfo -swf 0;
	//	check for funny looking edges (nonmanifold)
	//
	pt_checkManifoldEdges($obj);
	// undoInfo -swf 1;
	
	
	//	select edge
	//
	select (`polyListComponentConversion -fv -te $rVtxs`);

	//	make sure they're on the border
	//	
	polySelectConstraint -w 1 -m 2 -type 0x8000;
	resetPolySelectConstraint;
	
	
	//	make sure edge list is greater than 0
	//
	if (size(`ls -sl -fl`)>1)
		polySewEdge -t 0.01 -tx 0 -ws 1;

	// clear $edges;
	// clear $vtxs;
	// clear $rVtxs;

	//	delete history
	//
	// undoInfo -swf 0;
	int $locked[]=`lockNode -q $obj`;
	if ($locked[0] == 1){
		pt_setLockedNode("delete -ch "+$obj,$obj);
		}
	else{
		
		delete -ch $obj;
		}
	// undoInfo -swf 1;

	select -cl;
	print (`timerX -st $start`);
}

//CHECK FOR MANIFOLD EDGES
global proc pt_checkManifoldEdges(string $obj)
{
string $mVtxs[]=`polyInfo -nmv $obj`;
string $merge;
string $dump[];
for ($mVtx in $mVtxs){
	$merge="polyMergeVertex ";	

	select $mVtx;

	polySelectConstraint -w 1 -m 2 -pp 1 -type 1;
	resetPolySelectConstraint;
	$dump=`ls -sl -fl`;
	for ($d in $dump){
		if (!(stringArrayCount($d,$mVtxs)))
			$merge=$merge+$d+" ";
		}
		eval($merge);
	}
clear $dump;
}


global proc pt_mergeEdges()
{
	if (size(`filterExpand -sm 32`)>0){
		string $obj[] = `ls -hl`;
		pt_removeColor();
		polySelectConstraint -w 1 -m 2 -type 0x8000;
		resetPolySelectConstraint;
		polyMergeVertex -d .001 (`polyListComponentConversion -fe -tv`);
		select (`polyListComponentConversion -in -fv -te`);
		// catchQuiet(eval("polySewEdge -t 0.001 -tx 0 -ws 1"));
		int $locked[]=`lockNode -q $obj[0]`;
		if ($locked[0] == 1)
			pt_setLockedNode("delete -ch "+$obj[0],$obj[0]);
		else
			delete -ch $obj[0];


		// polySelectConstraint -w 2 -m 2 -type 0x8009;
		// resetPolySelectConstraint;	
		select -cl;
		}
	else warning "Select Some Border Edges to Merge!";
}


global proc pt_removeColor()
{
	string $sel[]=`ls -sl`;
	select `polyListComponentConversion -fe -ff -fuv -tv`;
	if (pt_returnMayaVersion() == "6.0")
		polyColorPerVertex -rem ;
	else	
		polyColorPerVertex -nun -rem ;
	// polyColorPerVertex -nun -rgb .6 .6 .6;
	select $sel;
}


global proc pt_addColor(string $type)
{
	string $sel[]=`ls -sl`;
	string $obj[] = `ls -hl`;
	// select (`polyListComponentConversion -fe -tv`);
	switch ($type){
		case "Cut":
			polyColorPerVertex -rgb .2 .3 .4;
			break;
		case "Seam":
			if (pt_returnMayaVersion() == "6.0")
				polyColorPerVertex -rgb .2 0 .1;
			else
				polyColorPerVertex -nun -rgb .2 0 .1;
			break;
		}
		
	if (!`menuItem -q -cb pt_toggleColorMenu`)
		polyOptions -global -cs 0;
	else 	
		polyOptions -cs 1 $obj;
	select $sel;
}

//SORT BORDER EDGES
global proc string[] pt_sortEdgeOrder(string $edges[])
{
	$bEdges[0]=$edges[0];
	string $dump[];
	string $case;
		for ($i=0;$i<(size($edges)*2);$i++){
			if (`objExists $bEdges[$i]`){
				select $bEdges[$i];
				polySelectConstraint -w 1 -m 2 -pp 1 -type 0x8000;
				resetPolySelectConstraint;
				$dump=`filterExpand -sm 32`;
				for ($d in $dump){
					if (!(stringArrayCount($d,$bEdges))){
						$bEdges[$i+1]=$d;
						break;
						}
					}
				clear $dump;
				}
			}
	return $bEdges;
}



//SORT BORDER VTXS AND RETURN "STEPPED" LIST
global proc string[] pt_sortBorderVerts(string $vtxs[])
{
	int $num;
	string $sVtxs[];
	string $eVtxs[];
	string $bEdges[];
	
	for ($i=0;$i<size($vtxs);$i++){
		$num=0;

		select `polyListComponentConversion -fv -te $vtxs[$i]`;
		

		polySelectConstraint -w 1 -m 2 -type 0x8000;
		resetPolySelectConstraint;
		$bEdges=`filterExpand -sm 32`;
		if (size($bEdges)==0){

			$eVtxs[size($eVtxs)]=$vtxs[$i];
			}
		clear $bEdges;
		}
			
	return $eVtxs;
}

//CREATE SELECTION SET
global proc pt_createEdgeSelectionSet(string $name, string $node)
{
	
	// addAttr -ln ("peltingSet") -dt "string" $setName;
	
	string $setName=`sets -v 1 -em -n $name`;
	connectAttr -f ($setName+".message") ($node+".peltingEdgeList");
	lockNode $setName;
	// textScrollList -e -si ($setName) pt_edgeList;
	
	// pt_getStoredEdges(`ls -type objectSet`);
	
	// select $setName;
}


//STORE BORDER EDGES
global proc int pt_storeEdgeSelection(string $edges[], string $lists[],int $type, string $obj, int $bypass)
{
	$start = `timerX`;
	int $continue = 1;
	if (size($edges)>0){
		//string $oEdges[]=$edges;
		string $cVtxs[];
		// polySelectConstraint -w 1 -m 2 -type 0x8009;
		// resetPolySelectConstraint;
		string $setName;
		//$edges=`filterExpand -sm 32`;
		
 		
		// if (size($edges)>0){
		
		string $node = pt_returnCurrentPeltNode();
		string $name = `getAttr ($node+".peltingGroupName")`;
		// string $nodes[] = `listConnections -type unknown $lists[0]`;

		if ((size($lists)>0)&&($type==1)){
			// if ($bypass == 1){
				// $setName=$lists[0];
				// pt_setLockedNode(("delete "+$lists[0]+""),$lists[0]);
				// $continue = 1;
				// }
			// else if ((`confirmDialog -title "Create Set" -message ("Do you want to replace \""+$lists[0]+"\"?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)=="Yes"){
				$setName=$lists[0];
				pt_setLockedNode(("delete "+$lists[0]+""),$lists[0]);
				$continue = 1;
				// }	
			// else
				// $continue = 0;
			}
		else if (size($lists) == 0){
			$setName=($name+"_EdgeList");
			// pt_setLockedNode(("delete "+$lists[0]+""),$lists[0]);
			$continue = 1;
			// delete $lists[0];	
			}
		
		if ($continue == 1){
			if (pt_returnMayaVersion() == "6.0")
				polyColorPerVertex -rem $obj;
			else
				polyColorPerVertex -nun -rem $obj;

			
			$setName=`sets -v 1 -n $setName`;
			
			connectAttr -f ($setName+".message") ($node+".peltingEdgeList");

			pt_addColor("Seam");
			
			select (`polyListComponentConversion -fv -te -in`);
			lockNode $setName;
			// hilite $obj;
			print "Edges Stored!";
			print(`timerX -st $start`);
			
			}
		else
			print "Edges NOT Stored!";
		}
	else {
		warning "Select Some Edges!";
		}
	return $continue;
}

//GET STORED EDGES
global proc pt_getStoredEdges(string $objSets[])
{
	textScrollList -e -ra pt_edgeList;
	for ($objSet in $objSets){
		if (`objExists ($objSet+".peltingSet")`)
			textScrollList -e -a $objSet pt_edgeList;
		}
}


//ADD TO EDGE LIST
global proc pt_addToEdgeList(string $lists[], string $edges[])
{
if (size($edges)>0){
	if (size($lists)>0){
		select -add $lists[0];
		$edges=`filterExpand -sm 32`;
		// pt_storeEdgeSelection($edges, $lists,0);
		}
	else {
		warning "Select an Edge List!";	
	
		}
	
	}
else {
	warning "Select Some Edges!";
	}

}

//ADD CONTIGUOUS EDGES
global proc pt_continuousEdgeList(string $lists[], string $edges[], int $bypass)
{	
	string $names[]  =`textScrollList -q -si pt_pelt_groupList`;
	string $node = pt_returnNodeFromName($names[0]);

	select ($edges[0]);
	polySelectConstraint -w 1 -m 2 -type 0x8009;
	resetPolySelectConstraint;
	$edges = `ls -sl -fl`;
	string $match = `match ".e[[]" $edges[0]`;
 	// $edges=`filterExpand -sm 32`;
	if ($match != ""){
		string $objs[] = `ls -hl`;
		string $obj = `match "^.+[!.]" $edges[0]`;
		$obj = `substring $obj 1 (size($obj) -1 )`;
		
		string $sVtxs[] =`polyListComponentConversion -fe -tv`;
		//$sVtxs = `ls -fl $sVtxs`;

		select $obj;
		string $bEdges[]=`polyInstallAction -cs polyCloseBorder`;
		polyInstallAction -uc;
		
		string $bVtxs[] =`polyListComponentConversion -fe -tv`;
		$bVtxs = `ls -fl $bVtxs`;

		string $nVtxs[];
		string $nEdges[];
		
		string $fVtxs[];
		$nVtxs[0]=$sVtxs[0];
		int $size=`size($bVtxs)`;
		select -cl;
		$start = `timerX`;
		DisplayWireframe;
		waitCursor -state on;
		undoInfo -swf 0;
		for ($i=1;$i<$size+10;$i++){
			if (`objExists $nVtxs[$i-1]`){
				select -add $nVtxs[$i-1];
				refresh -cv;
				$fVtxs=pt_getSurrVtxs($nVtxs[$i-1]);
				
			//get vtx not already in list and on edge
				for ($fVtx in $fVtxs){		 
					if ((stringArrayCount($fVtx,$bVtxs)>0)&&(stringArrayCount($fVtx, $nVtxs)<1)){
						$nVtxs[$i]=$fVtx;
						break;
						}
					}
				if (($nVtxs[$i]=="")&&($i!=size($bVtxs)-1)){	
					break;
					}
				}
			}
		 
		undoInfo -swf 1;
		// string $sEdges[] = `polyListComponentConversion -in -fv -te`;
		// 
		// $sEdges = `ls -fl`;

		DisplayShaded;
//		select $sEdges;
		// refresh -cv;
 		int $continue=pt_storeEdgeSelection(`ls -sl`, $lists,1, $obj, $bypass);
		// hilite $obj;
		if ($continue){
			setAttr ($node+".continuity") 1;
			setAttr ($node+".peltEnable") 1;
			pt_setManageState(pt_returnManageStates("Specific",$node));
			}
		waitCursor -state off;
		print (`timerX -st $start`);

		
		}
	else {
		warning "Select One Border Edge!";
		}	
 }



//MERGE OVERLAPPED BORDER
global proc pt_merge_overlapBorderEdges()
{
	string $objs[] = `ls -sl -fl`;
	int $combine;
	string $cmd;
	if (size($objs)>1)
		if (`confirmDialog -title "Merge Objects?" -message ("Combine Objects First?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`== "Yes")
			$combine = 1;

	if ($combine){
		$cmd = "polyUnite "+(pt_returnFirstItemInList($objs));
		string $nObjs[] = eval($cmd);
		clear $objs;
		$objs = {$nObjs[0]};
		}
		
	for ($obj in $objs){
		int $vCnt[] = `polyEvaluate -v $obj`;
		select ($obj+".vtx[0:"+$vCnt[0]+"]");
		polySelectConstraint -m 2 -w 1 -t 0x0001;
		resetPolySelectConstraint;
		polyMergeVertex -d .001;
		}
	select $objs;
	print "Border Edges Merged!";

}

//**************************************************************************
//
//				CREATE PELTING GROUP
//
//**************************************************************************

//CREATE PELT GROUP
global proc pt_createPeltGroup(string $name, int $bypass)
{
	
	textField -e -cc ("") ("pt_pelt_nameField");
	int $continue = 1;
	string $sel[] = `ls -sl`;
	string $grps[] = pt_returnPeltingGroups();
	string $originalMesh = pt_returnFirstItemInList(`textScrollList -q -ai pt_general_originalField`);

	if (size($sel) > 0){
		string $nodeType = `nodeType $sel[0]`;
		if ($nodeType == "mesh")
			$sel = `ls -hl`;
		if(`confirmDialog -title "Original Mesh" -message ("Use current object: \""+$sel[0]+"\" as Original?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"` == "Yes"){			
			if (pt_enterOriginalMesh($sel,{$name}) == 0){
				$continue= 0;
				}
			else
				$originalMesh = $sel[0];
			}
		else
			$continue = 0;
		}
	else if ($name != "")
		if(`confirmDialog -title "Original Mesh" -message ("Use input object: \""+$name+"\" as Original?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"` != "Yes")
			$continue = 0;
	//	check for name
	//
	if ($name == ""){
		warning "Enter Name for Pelting Group";
		$continue = 0;
		}
		
	//	check for original mesh
	//
	if ($continue == 1)
		if ($originalMesh == ""){
			warning "Enter Original Object Above First or Select Object!";
			$continue = 0;
			}
	if ($continue == 1){
		string $nodes[] = `listConnections -type unknown ($originalMesh+".message")`;
		for ($node in $nodes)
			if (`objExists ($node+".peltingGroupName")`){
				warning "Mesh Already Connected to Another Pelting Group";
				$continue = 0;
				break;
				}
		}

			
		
	if ($continue == 1){
		if (stringArrayCount($name, $grps) == 0){
			//	variables
			//
			string $unknown;
			string $grp;
			
			$unknown=`createNode unknown`;
			$unknown = `rename $unknown ($name+"PeltingNode")`;
			
			
			addAttr -ln peltingGroupName -dt "string" $unknown;
			setAttr -l true ($unknown+".peltingGroupName");
			pt_setLockedAttr($name,0,"peltingGroupName",$unknown);
			
			$grp = `group -em -n ($name+"_PeltingGrp")`;
			addAttr -ln "peltingType" -dt "string" $unknown;
			addAttr -ln "peltingGroup" -at "message" $unknown;
			addAttr -ln "peltingEdgeList" -at "message" $unknown;
			addAttr -ln "peltingOriginal" -at "message" $unknown;
			addAttr -ln "peltingComponentList" -at "message" $unknown;
			
			
			addAttr -ln "peltingMesh" -at "message" $unknown;
			addAttr -ln "peltingFrame" -at "message" $unknown;
			addAttr -ln "peltingSpring" -at "message" $unknown;
			addAttr -ln "peltingTextureMesh" -at "message" $unknown;
			addAttr -ln "peltingTextureFile" -dt "string" $unknown;
			addAttr -ln "peltingSimulatedMesh" -at "message" $unknown;
			
			addAttr -ln "sVtxEnable" -at long -min 0 -max 1 $unknown;
			addAttr -ln "mVtxEnable" -at long -min 0 -max 1 $unknown;
			addAttr -ln "peltingStartVtx" -at "message"  $unknown;
			addAttr -ln "peltingEndVtx" -at "message"  $unknown;
			addAttr -ln "extraEnable" -at long -min 0 -max 1 $unknown;
			
			
			addAttr -ln "peltingShader" -at "message"  $unknown;
			addAttr -ln "peltingU" -at double -min 0.001 $unknown;
			addAttr -ln "peltingV" -at double -min 0.001 $unknown;

			addAttr -ln "partsEnable" -at long -min 0 -max 1 $unknown;
			addAttr -ln "partsReuse" -at long -min 0 -max 1 $unknown;
			addAttr -ln "partsRegion" -at long -min 0 $unknown;
			addAttr -ln "edgeEnable" -at long -min 0 -max 1 $unknown;
			addAttr -ln "peltEnable" -at long -min 0 -max 1 $unknown;
			addAttr -ln "simulationEnable" -at long -min 0 -max 1 $unknown;
			addAttr -ln "visualisationEnable" -at long -min 0 -max 1 $unknown;
			
			
			setAttr -type "string" ($unknown+".peltingType") "Object";
			
			string $attrs[] = {"frameStrength","sCnt","sVtxs","meshStrength","extraStrength","walkLength", "conserve"};
			
			for ($attr in $attrs){
				addAttr -ln $attr -at double -min 0 $unknown;
				setAttr ($unknown+"."+$attr) 1;
				}

			setAttr ($unknown+".frameStrength") 10;
			setAttr ($unknown+".meshStrength") 100;
			setAttr ($unknown+".peltingU") 2.0;
			setAttr ($unknown+".peltingV") 2.0;
			
			addAttr -ln "paint" -at long -min 0 -max 1 $unknown;
			setAttr ($unknown+".paint") 0;
			
			addAttr -ln "continuity" -at long -min 0 -max 1 $unknown;
			setAttr ($unknown+".continuity") 0;

			string $dup[]=`duplicate -n ($name+"_PeltingMesh") $originalMesh`;
			int $faces[] = `polyEvaluate -f $dup[0]`;
			int $vrts[] = `polyEvaluate -v $dup[0]`;
			//	assign poly projection now to stop later problems
			//
			polyPlanarProjection ($dup[0]+".f[0:"+$faces[0]+"]");
			
			polyTransfer -vc 0 -uv 1 -v 0 -ao $dup[0] $originalMesh;
			setAttr ($originalMesh+".visibility") 0;
			
			connectAttr -f ($dup[0]+".message") ($unknown+".peltingMesh");
			connectAttr -f ($originalMesh+".message") ($unknown+".peltingOriginal");
			connectAttr -f ($grp+".message") ($unknown+".peltingGroup");
			setAttr ($unknown+".edgeEnable") 1;
			// pt_setMenuItems(1);

			pt_createEdgeSelectionSet($name+"_EdgeList",$unknown);
			pt_createElementSelectionList($name+"_ComponentList", $unknown);
			
			pt_createTextureFile($name);
			

			pt_populateGroupsList();
			
			string $layout = "general";
			textScrollList -e -ra ("pt_"+$layout+"_originalField");
			textScrollList -e -a $originalMesh ("pt_"+$layout+"_originalField");

			
			
			textScrollList -e -si $name pt_pelt_groupList;
			textField -e -tx "" ("pt_pelt_nameField");
			
			
			

			parent $dup[0] $grp;
			lockNode $originalMesh;
			lockNode $dup[0];
			lockNode $grp;
			lockNode $unknown;
			evalDeferred("pt_selectPeltGroup(\""+$name+"\")");
			textField -e -cc ("pt_createPeltGroup(`textField -q -tx pt_pelt_nameField`,0)") ("pt_pelt_nameField");
			// select $sel;
			}
		else{
			warning "Name Already Taken!";
			}
		}
	else
		textField -e -tx "" pt_pelt_nameField;
}


//CREATE TEXTURE FILE
global proc pt_createTextureFile(string $name)
{
	string $node = pt_returnNodeFromName($name);
	string $check=`internalVar -usd` + "Checker.png";
	if (`filetest -s $check`)
		setAttr -type "string" ($node+".peltingTextureFile") $check;
}


//**************************************************************************
//
//				CREATE PELTING FRAME
//
//**************************************************************************
global proc pt_createPeltingFrame(string $name, string $dir, int $bypass)
{
	select -cl;
	int $continue=1;
	string $node = pt_returnNodeFromName($name);
	string $bObjs[];
	string $frames[];
	string $edges[];
	int $parts = pt_returnPartsEnabled($node);
	if ($parts == 1){
		$bObjs=pt_returnPartsComponentList();
		if (size($bObjs) == 0){
			warning "Add A Vertex Shell To the Element List";
			$continue = 0;
			}
		}
	else
		$bObjs = `listConnections ($node+".peltingMesh")`;
	
	
	
		
	if ($node != ""){
		$frames = `listConnections ($node+".peltingFrame")`;
		$edges = `listConnections ($node+".peltingEdgeList")`;
		$edges = `sets -q $edges[0]`;
		if (size($edges) == 0){
			warning "Enter Edges into List First";
			$continue = 0;
			}
		}
	
	if (size($frames)>0){
		if ($bypass == 1){
			lockNode -l false $frames[0];
			delete $frames[0];
			}	
		else if(`confirmDialog -title "Create Frame" -message ("Do you want to replace \""+$frames[0]+"\"?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"` == "Yes"){
			lockNode -l false $frames[0];
			delete $frames[0];
			}
		else
			$continue = 0;

		}
	if ($continue == 1){
		
		//	find bounding box size
		//
 		float $bBox[6]=`exactWorldBoundingBox $bObjs`;
		float $bCenter[3] = {($bBox[0] + $bBox[3])/2,($bBox[1] + $bBox[4])/2,($bBox[2] + $bBox[5])/2};
		float $bSize[3] = {abs($bBox[3] - $bBox[0]),abs($bBox[4] - $bBox[1]),abs($bBox[5] - $bBox[2])};
		float $size[3] = `sort($bSize)`;  
		
		//	which axis to orient on?
		//
		int $axis[3];
		string $circles[];
	string $posAxes[3] = {"yz","xz","xy"};
		//	make sure the user hasn't already defined the axis
		//
		if ($dir == ""){
			$axis[2]=`iconTextRadioButton -q -sl pt_xy_frameButton`;
			$axis[1]=`iconTextRadioButton -q -sl pt_xz_frameButton`;
			$axis[0]=`iconTextRadioButton -q -sl pt_yz_frameButton`;
			}
		else
			for ($i=0;$i<3;$i++){
				if ($dir == $posAxes[$i])
					$axis[$i] = 1;
				else
					$axis[$i] = 0;
				}
					
		//	circle name and creation
		//
		string $circleName = ($name+"_Frame");
		
		string $circle[2]=`circle -r (2*$size[2]) -nr $axis[0] $axis[1] $axis[2] -c 0 0 0 -n ($circleName)`;
		setAttr ($circle[0]+".translate") $bCenter[0] $bCenter[1] $bCenter[2];
		
		//	make sure we're in the 0-1 range
		//
		$circle=`rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 $circle[0]`;
		connectAttr -f ($circle[0]+".message") ($node+".peltingFrame");
		
		//	populate out frames
		//
		setAttr ($node+".peltEnable") 1;
		pt_populateFrame($node);
		string $grps[] = `listConnections ($node+".peltingGroup")`;
		parent $circle[0] $grps[0];
		delete -ch $circle[0];
		lockNode $circle[0];
		}
}



//**************************************************************************
//
//				SELECTION
//
//**************************************************************************

//SELECT EDGE LIST
global proc pt_selectEdgeList(string $lists[])
{
	// selectMode -o;
	// select -cl;
	// selectMode -co;
	// setComponentPickMask "Line" true;
	
	select $lists[0];
	select (`polyListComponentConversion -fv -te -in`);
	string $objs[]=`listRelatives -p -pa`;
	hilite $objs;
}

global proc pt_selectPeltGroup(string $name)
{
	string $node = pt_returnNodeFromName($name);
	// textField -e -tx $name ("pt_pelt_nameField");
	columnLayout -e -en 1 pt_pelt_columnLayout2;
	pt_checkNode($name);
	pt_populateOriginalField($name);
	pt_populateGroupList($node);
	pt_populatePartsList($name);
	pt_populateEdgeList($node);
	pt_populateVtxs($node);
	pt_populateFrame($node);
	pt_populatePelt($node);
	pt_populateSimulation($name);
	pt_populateVisualisation($name);
	pt_setManageState(pt_returnManageStates("Specific",$node));
	
	select (`listConnections ($node+".peltingGroup")`);
	pt_resizeWindow();
}

global proc string pt_selectVtxs(string $names[],string $attr)
{
	string $set;
	string $vtxs[];
	string $node = pt_returnNodeFromName($names[0]);
	if (size(`listConnections ($node+"."+$attr)`)>0){
		selectMode -o;
		select -cl;
		selectMode -co;
		setComponentPickMask "Vertex" true;
		select `listConnections ($node+"."+$attr)`;
		$vtxs = `filterExpand -sm 31`;
		string $objs[]=`listRelatives -p -pa`;
		hilite $objs;

		// $set=$objSet;
		}
return $vtxs[0];
}


//SELECT PELT GROUP
global proc pt_selectPeltGrp(string $grp[], string $name, string $layout)
{
	string $node = pt_returnNodeFromName($name);
	select $grp;
	string $obj[]=`listConnections ($node+".peltingMesh")`;
	
	string $particle[]=`listRelatives -ad -pa -type particle $obj[0]`;
	string $spring[]=`listConnections ($node+".peltingSpring")`;
	
	floatSliderGrp -e -v (`getAttr ($node+".frameStrength")`) ("pt_"+$layout+"_reFrameSpringField");
	floatSliderGrp -e -v ((`getAttr ($node+".meshStrength")`)/100) ("pt_"+$layout+"_reMeshSpringField");
	
	connectControl ("pt_"+$layout+"_dampField") ($particle[0]+".conserve");
}


//SELECT PELT PARTS
global proc pt_selectPeltParts(string $attr, string $name)
{
	string $node = pt_returnNodeFromName($name);
	select (`listConnections ($node+"."+$attr)`);
}


global proc pt_selectLoop()
{
	pt_OMT_to_selectLoop;
}

global proc pt_shellSelectMode()
{
	$start = `timerX`;
	undoInfo -swf 0;
	string $sel[] = `ls -sl`;
	select (`polyListComponentConversion -ff -fv -fe -fuv -tv $sel[0]`);
	polySelectConstraint -m 2 -sh 1 -t 0x0001;
	resetPolySelectConstraint;
	undoInfo -swf 1;
	print (`timerX -st $start`);
}

//**************************************************************************
//
//				DELETE STUFF
//
//**************************************************************************

//DELETE SELECTED FRAME
global proc pt_deleteFrame(string $frames[])
{
	if (size($frames)>0){
		string $connections[] = `listConnections -type unknown ($frames[0]+".message")`;
		textScrollList -e -ra pt_frameList;
		lockNode -l false $frames[0];
		for ($connection in $connections)
			disconnectAttr ($frames[0]+".message") ($connection+".peltingFrame");
		delete $frames[0];
		}
}

//DELETE SELECTED PELT
global proc int pt_deletePelt(string $name)
{
	currentTime -e (`playbackOptions -q -ast`);
	string $node = pt_returnNodeFromName($name);
	
	string $meshes[];
	string $types[] = {"peltingTextureMesh","peltingSimulatedMesh","peltingSpring","peltingFrameSpring"};
	
	for ($type in $types){
		if (`objExists ($node+"."+$type)`){
			$meshes = `listConnections ($node+"."+$type)`;
			if (size($meshes)>0){
				$connections = `connectionInfo -dfs ($meshes[0]+".message")`;
				for ($connection in $connections)
					disconnectAttr ($meshes[0]+".message") $connection;
				pt_setLockedNode("delete "+$meshes[0],$meshes[0]);
				}
			}
		}

	//	deal with the shader
	//
	string $shaders[] = `listConnections ($node+".peltingShader")`;
	if (size($shaders)>0){
		string $shaderHistory[] = `listHistory $shaders[0]`;
		string $sEngine[] = `listConnections -type shadingEngine $shaders[0]`;
		delete $sEngine;
		for ($item in $shaderHistory)
			if ($item != $node)
				delete $item;
		}	
		
		
	string $mesh[] = `listConnections ($node+".peltingMesh")`;
	string $frames[] = `listConnections ($node+".peltingFrame")`;
	string $pShapes[] =`listRelatives -ad -pa -type particle $frames`;
	string $meshPShapes[] =`listRelatives -ad -pa -type particle $mesh`;
	// string $originals[] = `listConnections ($node+".peltingOriginal")`;
	print $meshPShapes;
	if (size($pShapes)>0)
		delete (`listRelatives -p $pShapes`);
	if (size($meshPShapes)>0)
		delete (`listRelatives -p $meshPShapes`);
	showHidden ($mesh);

	polyOptions -cs 1 $mesh;
	pt_setLockedNode("delete -ch "+$mesh[0],$mesh[0]);
	// polyColorPerVertex -rem $originals;
	pt_populateEdgeList($node);
	pt_populateVtxs($node);
	pt_populatePelt($node);
	pt_populateVisualisation($name);
	
	setAttr ($node+".simulationEnable") 0;
	setAttr ($node+".visualisationEnable") 0;
	setAttr ($node+".partsReuse") 0;
	setAttr ($node+".extraEnable") 0;
	setAttr ($node+".extraStrength") 0;
	// pt_getStoredPelts(`ls -type transform`);
	print ($name+" PELT Successfully Deleted");
	pt_setManageState(pt_returnManageStates("Specific",$node));
	return 1;
}

global proc pt_deletePeltGroup(string $names[])
{
	int $continue = 1;
	if ((`confirmDialog -title "Remove Pelt" -message ("Are you sure you want to entirely remove \""+$names[0]+"\"?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)!="Yes")
		$continue = 0;
	
	if ($continue == 1){
		string $attrs[] = {"peltingFrame","peltingMesh","peltingSimulatedMesh","peltingTextureFile","peltingSpring","peltingFrameSpring","peltingComponentList","peltingEdgeList","peltingStartVtx","peltingEndVtx","peltingShader","peltingGroup"};
		string $node = pt_returnNodeFromName($names[0]);
		string $mesh[];
		int $keep;
		int $partsEnable = `getAttr ($node+".partsEnable")`; 
		
		if (`getAttr ($node+".simulationEnable")`== 1)
			if ((`confirmDialog -title "Remove Pelt Sim" -message ("Do you want to remove \""+$names[0]+"\" pelt from simulation first?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)=="Yes")
				pt_removeSimPelt($names[0],0);
		
		if (($partsEnable == 1)&&(size(`listConnections ($node+".peltingMesh")`)>0))
			$keep = 1;
		else if (size(`listConnections ($node+".peltingSimulatedMesh")`)>0)
			$keep = 1;
		
		if ($keep == 1){
			if ((`confirmDialog -title "Keep UV in 3D" -message ("Do you want to keep your simluatedMesh? This one is maintaining a direct link to your original") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)=="Yes"){
				
				string $meshAttr;
				if ($partsEnable){
					$attrs = {"peltingFrame","peltingTextureFile","peltingSpring","peltingFrameSpring","peltingComponentList","peltingEdgeList","peltingStartVtx","peltingEndVtx","peltingShader","peltingGroup"};
					$meshAttr = "peltingMesh";
					}
				else{
					$attrs = {"peltingFrame","peltingMesh","peltingTextureFile","peltingSpring","peltingFrameSpring","peltingComponentList","peltingEdgeList","peltingStartVtx","peltingEndVtx","peltingShader","peltingGroup"};
					$meshAttr = "peltingSimulatedMesh";
					}
				$mesh = `listConnections ($node+"."+$meshAttr)`;
				lockNode -l false $mesh[0];				
				parent -w $mesh;
				disconnectAttr ($mesh[0]+".message") ($node+"."+$meshAttr);
				}
			}
		
		pt_deletePelt($names[0]);
		string $connections[];
		string $shapes[];

		for ($attr in $attrs){
			if (`objExists ($node+"."+$attr)`){
				$connections = `listConnections ($node+"."+$attr)`;
				if (size($connections)>0){
					if ($attr == "peltingMesh"){
						$shapes = `listRelatives -s $connections[0]`;
						pt_setLockedNode("delete "+$shapes[0],$shapes[0]);
						}
					pt_setLockedNode("delete "+$connections[0],$connections[0]);
					}
				}
			}
			
		string $originals[] = `listConnections ($node+".peltingOriginal")`;
		if (size($originals)>0){
			lockNode -l false $originals[0];
			disconnectAttr ($originals[0]+".message") ($node+".peltingOriginal");
			}
		
		pt_setLockedNode("delete "+$node,$node);
		
		if (`objExists $mesh[0]`)
			polyOptions -cs 0 $mesh[0];
		// print ($names[0]+" Successfully Removed");
		
		pt_populateGroupsList();
		pt_populatePartsList($names[0]);
		// pt_setMenuItems(0);
	
		pt_setManageState(pt_returnManageStates("Collapse",""));	
		string $frames[]=pt_returnFrameLayouts();
		frameLayout -e -m 1 ("pt_pelt_"+$frames[0]+"Frame");
		pt_resizeWindow();
		columnLayout -e -en 0 pt_pelt_columnLayout2;;
		textField -e -tx "" ("pt_pelt_nameField");
		showHidden $originals;
		}
}


//REMOVE PELT FROM SIM
global proc pt_removeSimPelt(string $name, int $bypass)
{
	if ($name!=""){
		int $continue = 1;
		string $md;
		string $simMesh[];
		// string $name = $names[0];
		string $node = pt_returnNodeFromName($name);
		int $parts = pt_returnPartsEnabled($node);
		int $reuse;
		if ($parts == 1){
			if ($bypass == 1)
				setAttr ($node+".partsReuse") 1;
			else if ((`confirmDialog -title "Continue Working?" -message ("Continue working with this mesh, or remove completely?") -button "Keep Working" -button "Remove"  -defaultButton "Keep Working" -cancelButton "Remove" -dismissString "Remove"`)=="Keep Working"){
				setAttr ($node+".partsReuse") 1;
				$reuse = 1;
				}
			else
				setAttr ($node+".partsReuse") 0;
			}

		string $mesh[]=`listConnections ($node+".peltingMesh")`;
		string $original[]=`listConnections ($node+".peltingOriginal")`;
		string $frames[]=`listConnections ($node+".peltingFrame")`;
		string $particles[] = `listRelatives -ad -pa -type particle $mesh`;
		
		
		
		if ($parts == 0){
			//	duplicate mesh object first
			//
			pt_toggleModelViews({$name}, "normals");			
			$simMesh=`duplicate -n ($name+"_SimulatedMesh") $mesh[0]`;
			string $children[] = `listRelatives -ad -pa -type particle $simMesh[0]`;
			delete (`listRelatives -pa -p $children`);
			$simMesh = `ls -l $simMesh[0]`;
			if (!`objExists ($simMesh[0]+".normalsView")`){
				lockNode -l false $simMesh[0];
				addAttr -ln normalsView -at long -min 0 -max 1 $simMesh[0]; 
				setAttr -e -k true ($simMesh[0]+".normalsView");
				}
			
			string $dump[] = `listConnections -p 1 ($node+".peltingSimulatedMesh")`;
			if (size($dump)>0)
				disconnectAttr $dump[0] ($node+".peltingSimulatedMesh");
			
			connectAttr ($simMesh[0]+".message") ($node+".peltingSimulatedMesh");			
			}		
		if ($parts == 1){
			pt_setLockedNode("delete -ch "+$mesh[0], $mesh[0]);	
			}
		

		//	then reconnect the particles if locked
		// 
		int $dynamic=`getAttr ($particles[0]+".isDynamic")`;
		if (!$dynamic){
			setAttr ($particles[0]+".isDynamic") 1;
			string $times[]=`ls -type time`;
			connectAttr ($times[0]+".outTime") ($particles[0]+".currentTime");
			setAttr ($particles[0]+".startFrame") (`playbackOptions -q -ast`);
			
			}
		refresh -f -cv;		
		
		//	then update the time
		//
		currentTime -e (`playbackOptions -q -ast`);
		string $dAttrs[] = {"peltingSpring","peltingFrameSpring","peltingTextureMesh"};
		for ($dAttr in $dAttrs){
			delete (`listConnections ($node+"."+$dAttr)`);
			}
		
		//	deal with the shader
		//
		string $shaders[] = `listConnections ($node+".peltingShader")`;
		if (size($shaders)>0){
			string $shaderHistory[] = `listHistory $shaders[0]`;
			string $sEngine[] = `listConnections -type shadingEngine $shaders[0]`;
			delete $sEngine;
			for ($item in $shaderHistory)
				if ($item != $node)
					delete $item;
			}
		
		string $part[2]=`listRelatives -ad -pa -type particle $frames[0]`;
		string $meshPart[2]=`listRelatives -ad -pa -type particle $mesh[0]`;
		delete (`listRelatives -pa -p $part[0]`);
		delete (`listRelatives -pa -p $meshPart[0]`);
				

		//	get the bounding box for the projection direction
		//
		float $bBox[3]=`getAttr ($frames[0]+".boundingBoxSize")`;
		float $axis[3]=`sort $bBox`;
		string $a[3]={"x","y","z"};
		for ($i=0;$i<3;$i++){
			if ($bBox[$i]==$axis[0]){
				$md=$a[$i];	
				
				}
			}
			
		
		if ($parts == 0){
			int $cnt[2]=`polyEvaluate -f $simMesh[0]`;
			polyProjection -ch 1 -type Planar -ibd on -icx 0.5 -icy 0.5 -ra 0 -isu 1 -isv 1 -md $md  ($simMesh[0]+".f[0:"+$cnt[0]+"]");
			if (pt_returnMayaVersion() == "6.0")
				polyColorPerVertex -rem $simMesh[0];
			else
				polyColorPerVertex -nun -rem $simMesh[0];
			
			polyOptions -cs 0 $simMesh[0];
			polyTransfer -vc 0 -uv 1 -v 0 -ao $simMesh[0] $original[0];
			
			polyNormalPerVertex -ufn 1 $simMesh[0];
			string $list[] =`listHistory $simMesh[0]`;
			for ($item in $list)
				if (`nodeType $item` == "polyNormalPerVertex")
					connectAttr -f ($simMesh[0]+".normalsView") ($item+".nodeState");
			
			setAttr ($simMesh[0]+".normalsView") 1;
			

			}
		else if ($parts == 1){
			int $cnt[2]=`polyEvaluate -f $mesh[0]`;
			string $sets[] = `listConnections ($node+".peltingComponentList")`;
			select $sets;
			select (`polyListComponentConversion -fv -tf`);
			polyProjection -ch 1 -type Planar -ibd on -icx (0.5+(`getAttr ($node+".partsRegion")`)) -icy 0.5 -ra 0 -isu 1 -isv 1 -sf 1 -md $md;
			select -cl;
			string $frames[] = `listConnections ($node+".peltingFrame")`;
			if ($frames[0] != ""){
				lockNode -l false $frames[0];
				delete $frames;
				}
			
			}
			
			
		
		pt_populateFrame($node);
		pt_populatePelt($node);
		showHidden $mesh;
		polyOptions -cs 1 $mesh;
		pt_setLockedNode("delete -ch "+$mesh[0],$mesh[0]);
		if ($reuse == 0){
			pt_toggleVis($node,0);
			if (`objExists initialShadingGroup`){
				string $lamberts[]=`listConnections initialShadingGroup.surfaceShader`;
				select $mesh;
				hyperShade -assign $lamberts[0];
				}
			// if (pt_returnMayaVersion() == "6.0")
				// polyColorPerVertex -rem $mesh;
			// else
				// polyColorPerVertex -nun -rem $mesh;
			// polyOptions -cs 0 $mesh;
			showHidden $original[0];
			warning ($name+" Group is Now Hidden - Use the \"vis\" button to make it visible");
			}
		if ($reuse == 1)
			setAttr ($node+".partsRegion") ((`getAttr ($node+".partsRegion")`)+1);

		
		if ($parts == 1)
			setAttr ($node+".peltEnable") 0;
		else
			setAttr ($node+".peltEnable") 1;
	
		string $shader=pt_applyImageToDuplicate (`textField -q -tx pt_imageField`, "General");
		
		if ($shader!=""){
			select $original;
			hyperShade -assign $shader;
			}
		setAttr ($node+".simulationEnable") 0;
		setAttr ($node+".visualisationEnable") 0;
		setAttr ($node+".extraEnable") 0;
		setAttr ($node+".extraStrength") 0;
		pt_setManageState(pt_returnManageStates("Specific",$node));
		// print ($original[0]+" UV'd and Ready to be textured");
		select -cl;
		// currentTime -e (`playbackOptions -q -ast`);
		// }
  		}
}



//**************************************************************************
//
//				SCRIPTED CMDS
//
//**************************************************************************


//FIRST STEPS FOR API
//
//GENERATE SCRIPTED CMD
global proc string pt_generateScriptedCmd(string $cmd, string $type)
{
	// string $cmd="cut;time 0;continuous;frame xy;pelt even;";
	
	//	split up cmd into parts
	//
	string $cmdParts[];
	string $cmds[];
	string $runCmds[];
	string $runOptions[];
	tokenize $cmd ";" $cmds;
	int $continue = 1;

	string $cmdParts[];
	tokenize $cmd ";" $cmdParts;
	int $continue;
	string $cmdList[];
	
	//	check first if the cmd is constructed properly
	//
	for ($i=0;$i<size($cmds);$i++){
		tokenize $cmds[$i] " " $cmdParts;
		if (pt_returnCmdOptions($cmds[$i])){
			//	check to see if the cmd is already used...
			//
			if (stringArrayCount($cmdParts[0], $runCmds)>0){
				warning ($cmdParts[0] +" used twice in same command - not allowed");
				$continue = 0;
				}
			else{
				print "success!";
				$runCmds[$i] = $cmdParts[0];
				$continue = 1;
				}
			}
		else{
			warning ($cmds[$i]+" Not formatted Correctly");
			$continue = 0;
			break;
			}
		}
	//	if correctly formatted, then return script or print
	//
	if ($continue == 1){
		if ($type == "script"){
			textField -e -tx ("pt_runScriptedCmd(\""+$cmd+"\")")("pt_pelt_scriptoutputField");
			print("\npt_runScriptedCmd(\""+$cmd+"\")");
			}
		if ($type == "cmd")
			return ("pt_runScriptedCmd(\""+$cmd+"\")");
		}

	return "";
}


//RUNS THE COMMAND
global proc pt_runScriptedCmd(string $cmd)
{
	string $cmdParts[];
	string $cmds[];
	string $runCmds[];
	string $runOptions[];
	tokenize $cmd ";" $cmds;
	int $continue = 1;
	
	//	get current pelt node - important at the moment for these scripts to run
	//
	string $node = pt_returnCurrentPeltNode();
	if ($node != ""){
		//	check to make sure the correct things are selected (if needed)
		//
		for ($i=0;$i<size($cmds);$i++){
			tokenize $cmds[$i] " " $cmdParts;
			if (!pt_checkScriptCmds($cmdParts[0]))
				$continue = 0;
			else{
				$runCmds[$i] = $cmdParts[0];
				$runOptions[$i] = $cmdParts[1];
				}
			}
		//	if all is clear, evaluate script
		//
		if ($continue == 1){
			print $runCmds;
			pt_assembleAndRunCmdOptions($runCmds, $runOptions, $node);
			}
		
		}
	else {
		warning "This cmd requires a Pelt Group to be Selected";
		$continue = 0;
		}
}
	
global proc int pt_checkScriptCmds(string $type)
{
	int $continue = 1;
	string $cmd = "This cmd requires ";
	switch ($type){
		case "cut": case "continuous": case "merge":
			string $sel[] = `ls -sl`;
			if(`match ".e[[]" $sel[0]`==""){
				$cmd += "Edges to be Selected";
				$continue = 0;
				}
			break;
		}
	if ($continue == 0)
		warning ($cmd);
			
	return $continue;
}


//ASSEMBLES ACTUAL CMDS
global proc string pt_assembleAndRunCmdOptions(string $cmds[], string $options[], string $node)
{
	string $sel[] = `ls -sl -fl`;
	string $edgeList = pt_returnFirstItemInList(`listConnections ($node+".peltingEdgeList")`);
	string $mesh = pt_returnFirstItemInList(`listConnections ($node+".peltingMesh")`);
	string $items[];	
	if ($edgeList != "")
		$items = `sets -q $edgeList`;

	int $continue = 1;
	for ($i=0;$i<size($cmds);$i++){
		if ($continue == 1){
			switch ($cmds[$i]){
				case "cut":
					pt_cutEdgesWorking($sel,"pelt");
					break;
				case "rewind":
					currentTime -e (`playbackOptions -q -ast`);
					break;
				case "continuous":
					select $sel[0];
					polySelectConstraint -w 1 -m 2;
					resetPolySelectConstraint;
					
					$sel = `ls -sl -fl`;
					if (size($sel) == 0){
						select ($mesh+".e[*]");
						polySelectConstraint -w 1 -m 2;
						resetPolySelectConstraint;
						$sel = `ls -sl -fl`;
						}
					select $sel[0];
					pt_continuousEdgeList(`listConnections ($node+".peltingEdgeList")`, `ls -sl`, 1);
					break;
				case "merge":
					if (size($items)>0){
						$sel = `ls -fl $items`;
						$sel = (`polyListComponentConversion -fv -te $sel[0]`);
						}
					pt_mergeEdges();
					break;
				case "frame":
					pt_createPeltingFrame(`getAttr ($node+".peltingGroupName")`, $options[$i], 1);			
					break;
				case "play":
					play;
					break;
				case "stop":
					play -st 0;
					break;
				case "pelt":
					$continue = pt_peltMesh(1, $options[$i]);
					break;
				case "deletePelt":
					pt_deletePelt(`getAttr ($node+".peltingGroupName")`);
					break;
				case "removePelt":
					pt_removeSimPelt(`getAttr ($node+".peltingGroupName")`,1);
					break;
				}
			}
		}
	
	
return "";	
}

//RETURNS IF THE COMMANDS HAVE PASSED FORMATTING CHECKS
global proc int pt_returnCmdOptions(string $cmd)
{
	string $cmds[] = {"rewind","cut","merge","continuous","frame","pelt","deletePelt","removePelt","play","stop"};
	string $options[] = {"","","","","xy xz yz","world even","","","",""};
	string $cmdOptions[];
	int $continue = 0;
	for ($i=0;$i<size($cmds);$i++){
		tokenize $options[$i] " " $cmdOptions;
		
		if ($options[$i] != ""){
			for ($cmdOption in $cmdOptions)
				if (`match (""+$cmds[$i]+" "+$cmdOption+"") (""+$cmd+"")` != "")
					$continue = 1;
			}
		else
			if (`match (""+$cmds[$i]+"") (""+$cmd+"")` != "")
				$continue = 1;
		}
		
	return $continue;
}

global proc pt_appendToCmd(string $type)
{
	string $layout = "script";
	string $current = `textField -q -tx ("pt_pelt_"+$layout+"Field")`;
	string $append;
	int $ip = `textField -q -ip ("pt_pelt_"+$layout+"Field")`;
	string $semi;
	if ($ip > 1){
		$semi = `substring  $current ($ip-1) ($ip-1)`; 
		if ($semi != ";")
			$append = ";";
		}
	
	
	
	string $cmds[] = {"rewind","cut","merge","continuous","frame","pelt","deletePelt","removePelt","play","stop"};
	string $defaults[] = {"","","","","xz","world","","","",""};
	for ($i=0;$i<size($cmds);$i++){
		if ($type == $cmds[$i]){
			if ($defaults[$i] != "")
				$append += $cmds[$i]+" "+$defaults[$i]+";";
			else
				$append += $cmds[$i]+";";
			}
		}
	textField -e -it $append -ip $ip ("pt_pelt_"+$layout+"Field"); 
}


//**************************************************************************
//
//				UTILITIES
//
//**************************************************************************

//RETURN FIRST INSTANCE IN ARRAY
global proc string pt_returnFirstItemInList(string $list[])
{
	return $list[0];
}


//RETURN PELTING GROUPS IN SCENE
global proc string[] pt_returnPeltingGroups()
{
	string $nodes[] = `ls -type unknown`;
	string $grps[];
	for ($node in $nodes)
		if (`objExists ($node+".peltingGroupName")`)
			$grps[size($grps)] = `getAttr ($node+".peltingGroupName")`; 
	return $grps;
}


global proc pt_toggleVertexColors(string $names[])
{
	string $sels[] = `ls -sl`;
	$sels = stringArrayCatenate($sels, `ls- hl`);
	int $vColor;
	int $colors[];
	string $node;
	if (size($sels) == 0){
		if (size($names)>0){
			$node = pt_returnNodeFromName($names[0]);
			string $attrs[] = {"peltingOriginal","peltingMesh","peltingTextureMesh","peltingSimulatedMesh"};
			string $connections[] = `listConnections ($node+"."+$attrs[0])`;
			$colors=`polyOptions -q -cs $connections`;
			if ($colors[0] == 0)
				$vColor = 1;
			else
				$vColor = 0;

			for ($attr in $attrs){
				$connections = `listConnections ($node+"."+$attr)`;
				if (size($connections)>0)
					polyOptions -cs $vColor $connections[0];
				}
			}
		}
	else{
		$colors=`polyOptions -q -cs $sels[0]`;
		if ($colors[0] == 0)
			$vColor = 1;
		else
			$vColor = 0;
		
		for ($sel in $sels)
			polyOptions -cs $vColor $sel;
		
		}
}

//SET LOCKED ATTRS
global proc pt_setLockedAttr(string $string, float $value, string $attr, string $obj)
{
	setAttr -l false ($obj+"."+$attr);
	if ($string != "")
		setAttr -type "string" ($obj+"."+$attr) $string;
	setAttr -l true ($obj+"."+$attr);
}	

//SET LOCKED NODE
global proc pt_setLockedNode(string $cmd, string $obj)
{
	if (`objExists $obj`){
		lockNode -l false $obj;
		eval($cmd);
		if (`objExists $obj`)
			lockNode -l true $obj;
		}
}


//SET FRAME AXIS
global proc pt_setFrameAxis(string $frames[], string $axisNew)
{
	if (size($frames)>0){
		//	get and declare axes
		//
		string $rotateAxis;
		string $axisOld=pt_getPeltAxis($frames[0]);
		string $axisCoords[3]= {"x","y","z"};
		
		float $rotateAxes[3];
	
		if ($axisOld != $axisNew){
			for ($i=0;$i<3;$i++)
				if (($axisCoords[$i] != $axisNew)&&($axisCoords[$i] != $axisOld))
					$rotateAxes[$i] = 1;
				else
					$rotateAxes[$i] = 0;

			xform -r -ro ($rotateAxes[0]*90) ($rotateAxes[1]*90) ($rotateAxes[2]*90) $frames[0];
			makeIdentity -a 1 -r 1 $frames[0];
			}
		print ($axisNew+"     "+$axisOld+"\n");
		print $rotateAxis;
		
		}
}


//TOGGLE VISIBILITY
global proc pt_toggleVis(string $node,int $value)
{
	string $layout = "groups";
	if ($node!=""){
		string $original[]=`listConnections ($node+".peltingOriginal")`;	
		string $grps[] = `listConnections ($node+".peltingGroup")`;
		if ($value == 1){
			
			iconTextCheckBox -e -bgc .47 .52 .55 ("pt_"+$layout+"_visButton");
/* 			if (`getAttr ($original[0]+".visibility")` == 1){
				if ((`confirmDialog -title "Hide Original?" -message ("Hide Original?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)=="Yes")
					hide (`listConnections ($node+".peltingOriginal")`);
				}
 */
			}
		else{
			iconTextCheckBox -e -bgc .27 .27 .32 ("pt_"+$layout+"_visButton");
/* 			if (`getAttr ($original[0]+".visibility")` == 0){
				if ((`confirmDialog -title "Show Original?" -message ("Show Original?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)=="Yes")
					showHidden (`listConnections ($node+".peltingOriginal")`);
				}
 */			}
		 if (`iconTextCheckBox -q -v ("pt_"+$layout+"_visButton")` == $value)
			iconTextCheckBox -e -v (!$value) ("pt_"+$layout+"_visButton"); 
		setAttr ($grps[0]+".visibility") ($value);
		
		}
}





//RETURN LAYOUT STATES
global proc int[] pt_returnManageStates(string $type, string $node)
{
	int $states[];
	string $frames[] = pt_returnFrameLayouts();
	switch($type){
		case "Expand":
			for ($frame in $frames)
				$states[size($states)] = 1;
			break;
		case "Collapse":
			for ($frame in $frames)
				$states[size($states)] = 0;
			break;
		case "Specific":
			string $attrs[] = pt_returnNodeAttrs();
			for ($i=1;$i<size($attrs);$i++)
				if (`getAttr ($node+"."+$attrs[$i])` == 1)
					$states[$i] = 1;
			$states[0] = 1;
			break;
		case "SpecificElement":
			string $attrs[] = pt_returnNodeAttrs();
			for ($i=2;$i<size($attrs);$i++)
				if (`getAttr ($node+"."+$attrs[$i])` == 1)
					$states[$i] = 1;
			$states[0] = 1;
			$states[1] = 1;
			break;
		
		}
	return $states;
	
}

//RETURN CURRENT TAB LABEL
global proc string pt_returnCurrentTab()
{
	string $name = `tabLayout -q -st pt_TabLayout`;
	string $parts[];
	tokenize $name "_" $parts;
	return $parts[1];
}


//RETURN LAYOUT NAMES
global proc string[] pt_returnFrameLayouts()
{
	string $frames[] = {"groups","parts","edge","pelt","simulation","visualisation"};
	
	return $frames;
	
}

//RETURN PELT NODE ATTRS 
global proc string[] pt_returnNodeAttrs()
{
	string $attrs[] = {"peltingGroupName","partsEnable","edgeEnable","peltEnable","simulationEnable","visualisationEnable"};	
	return $attrs;	
}

global proc string pt_returnNodeFromName(string $name)
{
	string $unknown;
	string $nodes[] = `ls -type unknown`;
	for ($node in $nodes)
		if (`objExists ($node+".peltingGroupName")`)
			if (`getAttr ($node+".peltingGroupName")` == $name)
				$unknown = $node;
	return $unknown;
	
}


//RETURN MAYA VERSION
global proc string pt_returnMayaVersion()
{
	string $about = `about -v`;
	string $version=`match "[0-9]\.[0-9]" (""+$about+"")`;
	return $version;
}

//RETURN BUTTON TYPE	IN PROGRESS IDEA:::
//
global proc string pt_returnButtonCmd(string $name, string $command, string $font, string $image, string $style, string $ann, string $label, string $bgc, string $h)
{	
	return ("iconTextButton -bgc "+$bgc+" -h "+$h+" -fn \""+$font+"\" -i \""+$image+"\" -style \""+$style+"\" -l \""+$label+"\" -ann \""+$ann+"\" -c (\""+$command+"\") "+$name);
	// return ("button -bgc "+$bgc+" -h "+$h+" -l \""+$label+"\" -ann \""+$ann+"\" -c (\""+$command+"\") "+$name);
}

global proc string pt_returnButtonType()
{
	return "iconTextButton";
	
}

global proc int pt_returnVertexColorSetting()
{
	int $colors[]=`polyOptions -q -cs`;
	return $colors[0];
	
}

global proc pt_toggleGlobalVertexColors(int $value)
{
	polyOptions -global -cs $value;
}

global proc pt_preMenuOptionsCmd()
{
	string $panel = pt_returnCurrentModelPanel();
	if ($panel != "")
		menuItem -e -cb (`modelEditor -q -dynamics $panel`) pt_showDynamicsMenu; 
}

global proc pt_toggleShowDynamics(int $value)
{
	string $panel = pt_returnCurrentModelPanel();
	if ($panel != "")
		modelEditor -e -dynamics $value $panel;	
}

global proc string pt_returnCurrentModelPanel()
{
	string $panel = `getPanel -withFocus`;
	if (`getPanel -to $panel` ==  "modelPanel") 
		return $panel;
	else
		return "";
}

global proc string[] pt_returnIntersectedItems(string $items[], string $lists[])
{
	string $int = `stringArrayIntersector`;
 	string $cParts[];
 
 	stringArrayIntersector -edit -intersect $lists $int;
 	stringArrayIntersector -edit -intersect $items $int;
 	$cParts = `stringArrayIntersector -q $int`;
 	deleteUI $int;

 	return $cParts;
}


global proc float pt_getDistanceBetweenPnts(string $pnt1, string $pnt2)
{
		float $pos[3] = `pointPosition $pnt1`;
		float $tPos[3] = `pointPosition $pnt2`;
		float $dir = mag(<<$pos[0] - $tPos[0],$pos[1] - $tPos[1],$pos[2] - $tPos[2]>>);
		return $dir;
}

global proc string pt_closestPointToPnt(string $sPnt, string $tPnts[])
{
	
	float $tPos[3];
	float $dist=1000;
	float $pDist;
	string $cPnt;
	for ($tPnt in $tPnts){
		$pDist=pt_getDistanceBetweenPnts($sPnt, $tPnt);
		if ($pDist < $dist){
			$dist = $pDist;
			$cPnt = $tPnt;
			}
		}
	return $cPnt;	
}


global proc pt_createVertexConstraint(string $vtx, string $obj)
{
	float $dist;
	float $pos[3] = `pointPosition $vtx`;
	string $shapes[] = `listRelatives -s -pa $obj`;
	string $sVtxs[] = pt_getSurrVtxs($vtx);
	string $cEdges[]=`polyListComponentConversion -fv -te -in $vtx $sVtxs[0]`;
	
	int $eId = pt_getIndexFromComponent($cEdges[0]);
 	string $nEdge=`createNode curveFromMeshEdge`;
	string $cInfo = `createNode pointOnCurveInfo`;

	string $loc=`createNode locator`;
	$loc = pt_returnFirstItemInList(`listRelatives -p $loc`);

	setAttr ($cInfo+".turnOnPercentage") 1;
	setAttr ($nEdge+".ei[0]") $eId;
	connectAttr ($shapes[0]+".worldMesh") ($nEdge+".inputMesh");
	connectAttr ($nEdge+".outputCurve") ($cInfo+".inputCurve");
	connectAttr ($cInfo+".position") ($loc+".translate");
	
	float $tPos[3] = `getAttr ($cInfo+".position")`;
	$dist = `mag<<$pos[0] - $tPos[0],$pos[1] - $tPos[1],$pos[2] - $tPos[2]>>`;
	setAttr ($cInfo+".parameter") 1;
	$tPos = `getAttr ($cInfo+".position")`;
	if (`mag<<$pos[0] - $tPos[0],$pos[1] - $tPos[1],$pos[2] - $tPos[2]>>` > $dist)
		setAttr ($cInfo+".parameter") 0;
}

global proc int pt_getIndexFromComponent(string $comp)
{
	string $match = `match "[0-9]+\]" $comp`;
	$match = `substring $match 1 (size($match)-1)`;
	int $id = int($match);
	return $id;
}

global proc int pt_enterOriginalMesh(string $objs[], string $names[])
{
	int $continue = 1;
	if (size($objs) != 1){
		warning "Select One Object";
		$continue = 0;
		}
	if ($continue == 1){
		string $nodes[] = `listConnections -p 1 -type unknown ($objs[0]+".message")`;
		for ($node in $nodes)
			if (`gmatch $node "*peltingOriginal"`){
				warning "Mesh Already Connected to Pelting Group";
				$continue = 0;
				}
		}

	return $continue;
}

global proc int pt_lockSimPelt(string $names[], int $dynamic, string $control)
{
	string $node=pt_returnNodeFromName($names[0]);
	string $peltingMesh[] = `listConnections ($node+".peltingMesh")`;
	string $particles[] = `listRelatives -ad -pa -type particle $peltingMesh`;

	switch($dynamic){
		case 1:
			string $dConn[] = `listConnections -p 1 ($particles[0]+".isDynamic")`;
			if (size($dConn)>0)
				disconnectAttr ($dConn[0]) ($particles[0]+".isDynamic");
			setAttr ($particles[0]+".isDynamic") 0;
			string $timeConn[] = `listConnections -p 1 ($particles[0]+".currentTime")`;
			disconnectAttr ($timeConn[0]) ($particles[0]+".currentTime");
			setAttr ($particles[0]+".startFrame") -1000000;
			iconTextCheckBox -e -l "UNLOCK PELT" $control;
			break;
		case 0:
			string $times[]=`ls -type time`;
			string $dConn[] = `listConnections -p 1 ($particles[0]+".isDynamic")`;
			if (size($dConn)>0)
				disconnectAttr ($dConn[0]) ($particles[0]+".isDynamic");
			setAttr ($particles[0]+".isDynamic") 1;
			connectAttr ($times[0]+".outTime") ($particles[0]+".currentTime");
			setAttr ($particles[0]+".startFrame") (`playbackOptions -q -ast`);
			iconTextCheckBox -e -l "LOCK PELT" $control;
			break;
		}
	return $dynamic;
	
}


global proc pt_toggleAddSpringFrame(string $names[])
{
	string $node=pt_returnNodeFromName($names[0]);
	string $peltingSpring[] = `listConnections ($node+".peltingSpring")`;
	
	string $layout = "simulation";
	int $check = `iconTextCheckBox -q -v ("pt_"+$layout+"_addSpringBox")`;
	
	frameLayout -e -bv $check -cl (!$check) ("pt_"+$layout+"_springFrame");
	if (size($peltingSpring)>0)
		setAttr ($peltingSpring[0]+".visibility") $check;	
	
}
global proc pt_addPerVertexSprings(string $names[])
{
	string $layout = "simulation";
	string $sel[] = `filterExpand -sm 31`;
	string $objs[] = `ls -hl -fl`;
	string $node=pt_returnNodeFromName($names[0]);
	string $peltingSpring[] = `listConnections ($node+".peltingSpring")`;
	string $peltingMesh[] = `listConnections ($node+".peltingMesh")`;
	int $nLength = `intFieldGrp -q -v1 pt_addLengthField`;
	int $oLength = `getAttr ($node+".walkLength")`;
	
	int $continue = 1;

	//	if, for some reason, the mesh isn't highlighted
	//
	if (size($objs) == 0){
		warning "Mesh needs to be highlighted";
		$continue = 0;
		}

	//	check walkLengths
	//
	if (!($nLength > $oLength)){
		warning "Enter walk length greater than current";
		$continue = 0;
		}

		
	//	make sure verts are selected
	//
	if (size($sel) == 0){
		warning "Select Mesh Vertices First";
		$continue = 0;
		}
	
	//	make sure mesh is the pelting mesh
	//
	if (size($objs)> 0)
		if ($objs[0] != $peltingMesh[0]){
			warning "Make sure vertices are from Pelting Mesh";
			$continue = 0;
			}

	
		
	if (size($peltingSpring) == 0){
		warning "Pelt mesh first";
		$continue = 0;
		}
		
	//	if all is well
	//
	if ($continue == 1){
		waitCursor -state 1;
		currentTime -e (`playbackOptions -q -ast`);
		spring -add -noDuplicate true -wireframe true -wl $nLength $sel $peltingSpring;
		pt_reSpringStrength($names,`floatSliderGrp -q -v ("pt_"+$layout+"_reExtraSpringField")`, "Extra");
		if (`getAttr ($node+".extraEnable")` == 0){
			frameLayout -e -cl 0 ("pt_"+$layout+"_extraFrame");
			setAttr ($node+".extraEnable") 1;
			}
		waitCursor -state 0;
		warning "Run playback again";
		window -e -h ((`window -q -h peltingTools`)+21) peltingTools;
		}
}


global proc pt_visitWebSite()
{
	showHelp -absolute "http://www.sunitparekh.com/pelting";
}

//**************************************************************************
//
//				UV TOOLS 
//
//**************************************************************************


//MOVE UVS
global proc pt_normalizeUV(string $uvs[], string $type)
{ 
	$uvs = `filterExpand -sm 35 $uvs`;
	if (size($uvs) > 0){
		$start = `timerX`;
		float $bBox[4] = `polyEvaluate -bc2`;
		float $pvts[2]= {($bBox[0]+$bBox[1])/2,($bBox[2]+$bBox[3])/2};

		print $pvts[1];
		//	get value to move to
		//
		for ($i=0;$i<2;$i++)
			$pvts[$i] = floor($pvts[$i]);
		
		select (`polyListComponentConversion -fuv -tf`);
		polyNormalizeUV;
		string $cmd;
		select $uvs;
		
		undoInfo -swf 0;
		if ($type == "smaller")
			polyEditUV -r 1 -pu .5 -pv .5 -su .99 -sv .99 $uvs;
			// $cmd = "polyEditUV -r 1 -u "+$pvts[0]+" -v "+$pvts[1]+" -pu .5 -pv .5 -su .99 -sv .99";
			// polyEditUV -r 1 -pu .5 -pv .5 -su .99 -sv .99 $uvs;		
		$cmd = "polyEditUV -r 1 -u "+$pvts[0]+" -v "+$pvts[1];
		undoInfo -swf 1;
		// print $cmd;
		
		if (($pvts[0] != 0)||($pvts[1] != 0))
			eval($cmd);
		print (`timerX -st $start`);
		// floatField -e -v 0 ($name+"_"+$type+"ScaleField");
		}
}

//MOVE UVS
global proc pt_moveUV(string $uvs[], float $dir, string $type, string $name)
{
	$uvs = `filterExpand -sm 35 $uvs`;
	if (size($uvs) > 0){
		string $cmd = "polyEditUV -r 1 -"+$type+" "+$dir;
	
		eval($cmd);

		floatField -e -v 0 ($name+"_"+$type+"MoveField");
		}
}

//SCALE UVS
global proc pt_scaleUV(string $uvs[], float $dir, string $type, string $name)
{
	$uvs = `filterExpand -sm 35 $uvs`;
	if (size($uvs) > 0){
		float $bBox[4] = `polyEvaluate -bc2`;
		float $pvt;
		float $pvt2;
		string $cmd;
		if (!`checkBox -q -v ($name+"_lockScaleBox")`)
			$type = "uv";
		if ($type == "u"){
			$pvt= ($bBox[0]+$bBox[1])/2;
			$cmd = "polyEditUV -r 1 -p"+$type+" "+$pvt+" -s"+$type+" "+$dir;
			}
		else if ($type == "v"){
			$pvt = ($bBox[2]+$bBox[3])/2;
			$cmd = "polyEditUV -r 1 -p"+$type+" "+$pvt+" -s"+$type+" "+$dir;
			}

		else if ($type == "uv"){
			$pvt = ($bBox[0]+$bBox[1])/2;
			$pvt2 = ($bBox[2]+$bBox[3])/2;
			$cmd = "polyEditUV -r 1 -pu "+$pvt+" -pv "+$pvt2+" -su "+$dir+" -sv "+$dir;
			$type = "u";
			}
		eval($cmd);

		
		floatField -e -v 0 ($name+"_"+$type+"ScaleField");
		}
}



//**************************************************************************
//
//				MULTI ELEMENT 
//
//**************************************************************************

//CREATE ELEMENT SET
global proc pt_createElementSelectionList(string $name, string $node)
{
	string $setName=`sets -v 1 -em -n ($name)`;
	connectAttr -f ($setName+".message") ($node+".peltingComponentList");
	lockNode $setName;
}


global proc pt_storeComponentList(string $lists[], string $vtxs[])
{
	string $match = `match ".vtx[[]" $vtxs[0]`;
	
 	string $node = pt_returnCurrentPeltNode();
	int $continue = 1;

	if ($match == ""){
		warning "Select A Vertex Shell";
		$continue = 0;
		}

	if (`getAttr ($node+".simulationEnable")` ==1){
		warning "Remove Simulation First!";
		$continue = 0;
		}
 		
	if ($continue == 1)
		if ((`confirmDialog -title "Create Set" -message ("Do you want to replace \""+$lists[0]+"\"?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)!="Yes")
			$continue = 0;
	
	if ($continue == 1){
		$start = `timerX`;	

		pt_setLockedNode("delete "+$lists[0],$lists[0]);
		string $node = pt_returnCurrentPeltNode();
		string $name = `getAttr ($node+".peltingGroupName")`;
		string $shader;
		string $engines[1];
 		string $obj = `match "^.+[!.]" $vtxs[0]`;
		$obj = `substring $obj 1 (size($obj) -1 )`;
		string $shapes[] = `listRelatives -s $obj`;
		int $sizeVtxs = `getAttr -s ($shapes[0]+".vrts")`;
		int $sizeFace = `getAttr -s ($shapes[0]+".face")`;
 		
		undoInfo -swf 0;
		// select $vtxs;
		string $setName=`sets -v 1 -n ($name+"_ComponentList")`;
		undoInfo -swf 1;
		connectAttr -f ($setName+".message") ($node+".peltingComponentList");
		lockNode $setName;
		
		//	delete old stuff
		//
		string $frames[] = `listConnections ($node+".peltingFrame")`;
		if (size($frames)>0)
			pt_setLockedNode("delete "+$frames[0],$frames[0]);

		
		
    		//	check for the peltingParts shader
		if (`objExists ("PeltingPartsShader")`){
			$shader = "PeltingPartsShader";
			$engines = `listConnections -type shadingEngine $shader`;
			}
		//	else make the shader
		//
		else{
			string $sel[] = `ls -sl`;
			$shader=`shadingNode -asShader lambert`;
			$shader=`rename $shader ("PeltingPartsShader")`;
			setAttr "PeltingPartsShader.color" -type double3 0.225 0.225 0.225;
			select $sel;
			}
			
		
		//	check for initial shading group and assign
		//
		if (`objExists initialShadingGroup`){
			string $lamberts[1]=`listConnections initialShadingGroup.surfaceShader`;
		
			select (`polyListComponentConversion -fv -tf`);
			hyperShade -assign $lamberts[0];
			}

		//	assign parts shader to everything else
		//
		select -tgl ($obj+".f[0:"+($sizeFace-1)+"]");
		hyperShade -assign $shader;

		
		setAttr ($node+".sVtxEnable") 0;
		setAttr ($node+".mVtxEnable") 0;
		setAttr ($node+".peltEnable") 0;
		setAttr ($node+".simulationEnable") 0;
		setAttr ($node+".visualisationEnable") 0;

		
		pt_populateVtxs($node);
		pt_populateFrame($node);
		pt_setManageState(pt_returnManageStates("Specific",$node));
		hilite $obj;
		select $vtxs;		
		// print ("Components Successfully Stored!");
		print(`timerX -st $start`);
		}
}

global proc pt_selectComponentList(string $list)
{
	selectMode -o;
	select -cl;
	selectMode -co;
	setComponentPickMask "vertex" true;
	select $list;
	string $objs[]=`listRelatives -p -pa`;
	hilite $objs;
}




//TOGGLES MULTI ON/OFF FOR PELT GROUPS
global proc int pt_togglePartsElement(string $names[], int $value)
{
	string $node=pt_returnNodeFromName($names[0]);
	if ($node != ""){
		switch($value){
			case 1:
				setAttr ($node+".partsEnable") $value;
				break;
		
			case 0:
				setAttr ($node+".partsEnable") $value;
				break;

			// if ($value == 1)
				// pt_createVisualisationMeshes($names[0]);
			

			}
		pt_populatePartsList($names[0]);	
		}
	else
		warning "Select Group First";
	
	pt_resizeWindow();
	return $value;
}

global proc string pt_createVisualisationMeshes(string $name)
{
	string $node=pt_returnNodeFromName($name);
	string $grps[] =`listConnections ($node+".peltingGroup")`;
	string $originals[] = `listConnections ($node+".peltingOriginal")`;
	string $textureMesh[] = `listConnections ($node+".peltingTextureMesh")`;
	if (size($textureMesh) == 0){
		$textureMesh=`duplicate -n ($name+"_textureMesh") $originals[0]`;
		connectAttr -f ($textureMesh[0]+".message") ($node+".peltingTextureMesh");
		parent $textureMesh $grps[0];
		}
	return $textureMesh[0];
	
}

global proc pt_selectElementComponents(string $node)
{
	select (`listConnections ($node+".peltingMeshComponents")`);
	select (`polyListComponentConversion -fv -te`);
}

global proc int pt_returnPartsEnabled(string $node)
{
	int $enable;
	if (`getAttr ($node+".partsEnable")` == 1)
		$enable = 1;
	return $enable;
}

global proc string[] pt_returnPartsComponentList()
{
	string $vtxs[];
	string $node=pt_returnCurrentPeltNode();
	if ($node != ""){
		string $sets[] = `listConnections ($node+".peltingComponentList")`;
		$vtxs = `sets -q $sets[0]`;	
		}
	return $vtxs;
}


global proc string pt_returnCurrentPeltNode()
{
	string $names[1] =`textScrollList -q -si pt_pelt_groupList`;
	return (pt_returnNodeFromName($names[0]));
	
}

//**************************************************************************
//
//				TRANSFER UVS && CUT MESH AT SEAMS
//
//**************************************************************************

global proc pt_cutMeshAtSeams(string $objs[])
{
	waitCursor -state 1; 
	for ($obj in $objs){
		string $uvs = `polyEvaluate -uv -fmt $obj`; 
		int $uvCnt = int(`match "[0-9].+" $uvs`);
		select ($obj+".map[0:"+$uvCnt+"]");
		undoInfo -swf 0;
		polySelectConstraint -m 2 -w 1 -type 0x0010;
		resetPolySelectConstraint;
		select (`polyListComponentConversion -fuv -te -in`);
		undoInfo -swf 1;
		hilite ($obj);
		pt_cutEdges("");		
		}
	waitCursor -state 0;
}

global proc pt_transferUVS()
{
	int $continue=1;
	string $objs[] = `ls -sl -fl`;
	if (size($objs) != 2){
		warning "Need To Select Source AND Target";
		$continue = 0;
		}
	int $sVCnt[];
	int $tVCnt[];

	//	check if closestPointOnMesh is loaded
	//
	if ($continue == 1)
		if (!(`pluginInfo -q -l closestPointOnMesh`)){
			warning "closestPointOnMesh plugin needs to be loaded for transferUV";
			$continue = 0;
			}

	//	does the user really want to do this...?
	//
 	if ($continue == 1)
		if ((`confirmDialog -title "Transfer UVs" -message ("Command requires a SOURCE with CUT edge seams.  This may take a few minutes and is not currently escapable. Proceed?") -button "Yes" -button "No"  -defaultButton "Yes" -cancelButton "No" -dismissString "No"`)=="No")
			$continue = 0;
	
	if ($continue == 1){
		string $bSourceVtxs[];
		string $bTargetVtxs[];

		float $pos[3];
		float $tPos[3];
		float $pDist;
		float $dist;

		
		string $source = $objs[0];
		string $target = $objs[1];

		// string $dup[] = `duplicate $source`;
		
		$sVCnt = `polyEvaluate -v -uv -f $source`;
		$tVCnt = `polyEvaluate -v -uv -f $target`;
		
		//	create uv points for all faces in target
		//
		polyProjection -type Planar -isu 1 -isv 1 ($target+".f[0:"+$tVCnt[2]+"]");

		//	get border verts
		//
		select ($source+".vtx[0:"+$sVCnt[0]+"]");
		polySelectConstraint -m 2 -w 1 -t 0x0001;
		resetPolySelectConstraint;
		$bSourceVtxs = `filterExpand -ex true -sm 31`;
				
		//	find the border verts on the target 
		//
		progressWindow -title "Getting Border Vertices" -progress 0 -max (size($bSourceVtxs)) -status "Iterating Border Vertices: ";
		for ($i=0;$i<size($bSourceVtxs);$i++){
			$bTargetVtxs[$i] = pt_closestVertexOnMesh($bSourceVtxs[$i], $target);

			progressWindow -e -progress $i -status ("Iterating Border Vertices: "+$i+" out of "+size($bSourceVtxs));
			}
		
		
		select -cl;
		//	convert border verts to edges and cut
		//
		string $bEdges[]=`polyListComponentConversion -fv -te -in $bTargetVtxs`;
		string $mapCut[];
		if (size($bEdges)>0)
			 $mapCut= `polyMapCut $bEdges`;
		
		$bTargetVtxs = `polyListComponentConversion -fe -tv`;
		$bTargetVtxs = `filterExpand -sm 31 $bTargetVtxs`;
		
		
		// select $bDupVtxs;
		// polyMergeVertex -d .001;
		

		$tVCnt = `polyEvaluate -v -uv -f $target`;


		string $uvs[];
		string $bVtx;
		float $uvPos[];
		string $lVtxs[];

		//	place marker for undo...does it work?
		//
		polyEditUV -r 0 -u 0 -v 0 ($target+".map[0]");

		
		//	move uv points (except for border)
		//
		progressWindow -e -title "Moving UV Points" -progress 0 -max ($tVCnt[0]) -status "Editing UV: ";

		undoInfo -swf 0;
		for ($i=0;$i<$tVCnt[0];$i++){
			if (stringArrayCount(($target+".vtx["+$i+"]"), $bTargetVtxs) == 0){
				$uvs = `polyListComponentConversion -fv -tuv ($target+".vtx["+$i+"]")`;
				$pos = `pointPosition ($target+".vtx["+$i+"]")`;
				$uvPos=`closestPointOnMesh -ip $pos[0] $pos[1] $pos[2] -q -u -v $source`;
				for ($uv in $uvs){
					polyEditUV -r 0 -u $uvPos[0] -v $uvPos[1] $uv;
					}
				}
			progressWindow -e -progress $i -status ("Editing UV: "+$i+" out of "+$tVCnt[0]);
			}
		undoInfo -swf 1;
			
		//	get border uvs for target
		//
		string $tUV;
		string $dUVs[];
		string $uUVs[];
		string $bTargetUVs[] = `polyListComponentConversion -fv -tuv $bTargetVtxs`;		
		string $bSourceUVs[] = `polyListComponentConversion -fv -tuv $bSourceVtxs`;
		$bTargetUVs = `filterExpand -sm 35 $bTargetUVs`;
		
		
		
		$bSourceUVs = `filterExpand -sm 35 $bSourceUVs`;
		string $sVtxs[];
		string $rVtx;
		select -cl;
		
		//	get surrounding verts to border
		//
		for ($i=0;$i<size($bSourceVtxs);$i++){
			$rVtx =pt_getSurrInsideVtxs($bSourceVtxs[$i], $bSourceVtxs, "edge");
			if ($rVtx != "")
				$sVtxs[size($sVtxs)]=$rVtx;
			}
		

		int $size = size($sVtxs);
		progressWindow -e -title "Moving UV Points" -progress 0 -max $size -status "Editing Border UV: ";
		
		//	use surrounding verts to calculate new uv positions
		//
		undoInfo -swf 0;
 		for ($i=0;$i<size($sVtxs);$i++){ 			
			string $tVtx=pt_closestVertexOnMesh($sVtxs[$i], $target);
			string $tUVs[] = `polyListComponentConversion -fv -tuv $tVtx`;
			string $sTUVs[] = pt_getSurrUVs($tUVs[0], "edge");
			
			$sTUVs=pt_returnIntersectedItems($sTUVs, $bTargetUVs);

			string $sUVs[] = `polyListComponentConversion -fv -tuv $sVtxs[$i]`;
			string $sSUVs[] = pt_getSurrUVs($sUVs[0], "edge");
			$sSUVs=pt_returnIntersectedItems($sSUVs, $bSourceUVs);
			
			if (size($sTUVs)>1)
				$lVtxs[size($lVtxs)]=$sVtxs[$i];
			else
				for ($j=0;$j<size($sTUVs);$j++){
					$uvPos = `polyEditUV -q $sSUVs[$j]`;
					polyEditUV -r 0 -u $uvPos[0] -v $uvPos[1] $sTUVs[$j];
					$dUVs[size($dUVs)] = $sTUVs[$j];
					$uUVs[size($uUVs)] = $sSUVs[$j];
					}
			progressWindow -e -progress $i -status ("Editing Border UV: "+$i+" out of "+$size);
			}
		undoInfo -swf 1;
		select -cl;	
		//select $lVtxs;
		$size = size($lVtxs);
		if ($size > 0)
			progressWindow -e -title "Moving UV Points" -progress 0 -max $size -status "Editing Leftover Border UV: ";
		
		//	deal with leftover vertices that had more than one surrounding point
		//
		undoInfo -swf 0;
		for ($i=0;$i<size($lVtxs);$i++){
			string $tVtx=pt_closestVertexOnMesh($lVtxs[$i], $target);
			string $tUVs[] = `polyListComponentConversion -fv -tuv $tVtx`;
			
			
			
			//$tUVs = stringArrayRemove($dUVs, $tUVs);
			string $sTUVs[] = pt_getSurrUVs($tUVs[0], "edge");
			$sTUVs=pt_returnIntersectedItems($sTUVs, $bTargetUVs);
			$sTUVs = stringArrayRemove($dUVs, $sTUVs);
			
			string $sUVs[] = `polyListComponentConversion -fv -tuv $lVtxs[$i]`;
			//$sUVs = stringArrayRemove($uUVs, $sUVs);
			string $sSUVs[] = pt_getSurrUVs($sUVs[0], "edge");
			$sSUVs=pt_returnIntersectedItems($sSUVs, $bSourceUVs);
			$sSUVs = stringArrayRemove($uUVs, $sSUVs);
			
			for ($j=0;$j<size($sSUVs);$j++){
				string $cUV=pt_closestPointToPnt($sSUVs[$j], $sTUVs);
				$uvPos = `polyEditUV -q $sSUVs[$j]`;
				polyEditUV -r 0 -u $uvPos[0] -v $uvPos[1] $cUV;
				$dUVs[size($dUVs)] = $cUV;
				$uUVs[size($uUVs)] = $sSUVs[$j];
				}
			// select -add $sTUVs;
			// print $sTUVs;
			// print $sSUVs;
			progressWindow -e -progress $i -status ("Editing Leftover Border UV: "+$i+" out of "+$size);
			}			
		undoInfo -swf 1;
		//	still more "corner-type" verts
		//
		$lVtxs=stringArrayRemove($uUVs, $bSourceUVs);
		clear $sVtxs;
		//	get surrounding verts to border
		//
		for ($i=0;$i<size($lVtxs);$i++){
			$rVtx =pt_getSurrInsideVtxs($lVtxs[$i], $bSourceVtxs,"face");
			if ($rVtx != "")
				$sVtxs[size($sVtxs)]=$rVtx;
			}
		$size = size($sVtxs);
		if ($size > 0)
			progressWindow -e -title "Moving UV Points" -progress 0 -max $size -status "Editing Corner-type Border UV: ";			
				
		//select $sVtxs;
		undoInfo -swf 0;
  		for ($i=0;$i<size($sVtxs);$i++){
			string $tVtx=pt_closestVertexOnMesh($sVtxs[$i], $target);	
			string $tUVs[] = `polyListComponentConversion -fv -tuv $tVtx`;
			$tUVs = stringArrayRemove($dUVs, $tUVs);

			if ($tUVs[0] != ""){
				string $sTUVs[] = pt_getSurrUVs($tUVs[0], "face");
				$sTUVs=pt_returnIntersectedItems($sTUVs, $bTargetUVs);
				$sTUVs = stringArrayRemove($dUVs, $sTUVs);
	
				string $sUVs[] = `polyListComponentConversion -fv -tuv $sVtxs[$i]`;
				$sUVs = stringArrayRemove($uUVs, $sUVs);
				string $sSUVs[] = pt_getSurrUVs($sUVs[0], "face");
				$sSUVs=pt_returnIntersectedItems($sSUVs, $bSourceUVs);
				$sSUVs = stringArrayRemove($uUVs, $sSUVs);
				for ($j=0;$j<size($sTUVs);$j++){
					// if ((`objExists $sSUVs[$j]`)&&(`objExists $sTUVs[$j]`)){
						$uvPos = `polyEditUV -q $sSUVs[$j]`;
						polyEditUV -r 0 -u $uvPos[0] -v $uvPos[1] $sTUVs[$j];
						// }
 					}
				}
			progressWindow -e -progress $i -status ("Editing Corner-type Border UV: "+$i+" out of "+$size);
 			}
		undoInfo -swf 1;
		progressWindow -ep;	 		
		polyOptions -dmb 1 -db 1 $target;
		// select $source $target;
		progressWindow -ep;
		}
}

//GET CLOSEST VERTEX ON SURFACE
global proc string pt_closestVertexOnMesh(string $vtx, string $target)
{
	string $cVtx;
	float $pDist;
	float $dist = 10000;
	float $pos[3]=`pointPosition $vtx`;
	int $face=`closestPointOnMesh -ip $pos[0] $pos[1] $pos[2] -q -f $target`;
	
	string $vrts[]=`polyListComponentConversion -tv ($target+".f["+$face+"]")`;	
	
	$vrts=`filterExpand -sm 31 $vrts`;
	for ($vrt in $vrts){
		float $tPos[3]=`pointPosition $vrt`;
		$pDist=mag(<<($pos[0]-$tPos[0]),($pos[1]-$tPos[1]),($pos[2]-$tPos[2])>>);
		if ($pDist<$dist){
			$cVtx = $vrt;
			$dist=$pDist;
			}
		}
	return $cVtx;
}

global proc string[] pt_sortUVs(string $suv, string $uvs[], float $dir)
{
	string $fUVs[];
	string $nUVs[];
	float $dist;
	float $diff = 1000;
//vtxs start at $sVtx
	$nUVs[0]=$suv;
	int $size=`size($uvs)`;
	progressWindow -title "Sorting Through UVs" -progress 0 -max (`size($uvs)`) -status ("UV Count: ");
	for ($i=1;$i<(size($uvs));$i++){
		if (`objExists $nUVs[$i-1]`){
			$fUVs=pt_getSurrUVs($nUVs[$i-1], "edge");		
			
		
			if ($i == 1){
				//get vtx not already in list and on edge
				//
				for ($fUV in $fUVs){
					$dist = pt_getDistanceBetweenPnts($nUVs[0],$fUV);
					if (($dir-$dist<$diff)&&(stringArrayCount($fUV,$uvs)>0)&&(stringArrayCount($fUV, $nUVs)<1)){
						$diff = $dir-$dist;
						$nUVs[$i]=$fUV;
						}
					}
				}
			else
				for ($fUV in $fUVs){
					if ((stringArrayCount($fUV,$uvs)>0)&&(stringArrayCount($fUV, $nUVs)<1)){
						$nUVs[$i]=$fUV;
						break;
						}
					}
				
			if (($nUVs[$i]=="")&&($i!=size($uvs)-1)){	
				break;
				}
			}
		progressWindow -edit -progress $i -status ("UV Count: "+$i+" out of "+$size);
		}
	progressWindow -endProgress;
return $nUVs;
}


global proc string[] pt_getSurrUVs(string $uv, string $type)
{
	string $lEdges[10];
	string $lFaces[10];
	string $lUVs[10];
	string $fUVs[10];
	
	switch($type){
		case "edge":
		//convert to edges
			$lEdges=`polyListComponentConversion -fuv -te $uv`;
		
		//convert to vtxs
			$lUVs=`polyListComponentConversion -fe -tuv $lEdges`;
		
		//flatten vtxs
			$fUVs=`filterExpand -sm 35 $lUVs`;
			break;
		case "face":
		//convert to faces
			$lFaces=`polyListComponentConversion -fuv -tf $uv`;
		
		//convert to vtxs
			$lUVs=`polyListComponentConversion -ff -tuv $lFaces`;
		
		//flatten vtxs
			$fUVs=`filterExpand -sm 35 $lUVs`;
			break;
		}
//clear $lEdges;
//clear $lVtxs;
//clear $fVtxs;
return $fUVs;
}


global proc string pt_getSurrInsideVtxs(string $vtx, string $vtxs[], string $type)
{
	string $lEdges[10];
	string $lFaces[10];
	string $lVtxs[10];
	string $fVtxs[10];
	string $sVtxs[10];
	string $rVtx;
	switch($type){
		case "edge":
		//convert to edges
			$lEdges=`polyListComponentConversion -fv -te $vtx`;
		
		//convert to vtxs
			$lVtxs=`polyListComponentConversion -fe -tv $lEdges`;

			break;
		case "face":
		//convert to edges
			$lFaces=`polyListComponentConversion -fv -tf $vtx`;
		
		//convert to vtxs
			$lVtxs=`polyListComponentConversion -ff -tv $lFaces`;
			break;
		}

	//flatten vtxs
		$fVtxs=`filterExpand -sm 31 $lVtxs`;
		$fVtxs = stringArrayRemove($vtxs, $fVtxs);
				

		if (size($fVtxs)>1)
			for ($fVtx in $fVtxs){
				int $check = 0;
				$sVtxs=pt_getSurrVtxs($fVtx);
				for ($sVtx in $sVtxs)
					if (stringArrayCount($sVtx, $vtxs)>0)
						$check += 1;
				if ($check == 1){
					$rVtx = $fVtx;
					break;
					}
				}
		else
			$rVtx = $fVtxs[0];
return $rVtx;
}


//**************************************************************************
//
//				POPULATE LISTS
//
//**************************************************************************


global proc pt_populateGroupsList()
{
	string $grps[]=pt_returnPeltingGroups();
	textScrollList -e -ra ("pt_pelt_groupList");
	if (size($grps)>4)
		textScrollList -e -nr (size($grps)) ("pt_pelt_groupList");
	for ($grp in $grps)
		textScrollList -e -a $grp ("pt_pelt_groupList");
}

global proc pt_populateOriginalField(string $name)
{
	string $node=pt_returnNodeFromName($name);
	string $meshes[] = `listConnections ($node+".peltingOriginal")`;
	textScrollList -e -ra pt_general_originalField;
	textScrollList -e -a $meshes[0] pt_general_originalField;
	
}

global proc pt_populateGroupList(string $node)
{
	string $grps[] = `listConnections ($node+".peltingGroup")`;
	string $layout = "groups";
	if (`getAttr ($grps[0]+".visibility")`==0)
		iconTextCheckBox -e -bgc .27 .27 .32 -v 1 ("pt_"+$layout+"_visButton");
	else
		iconTextCheckBox -e -bgc .47 .52 .55 -v 0 ("pt_"+$layout+"_visButton");		
}

global proc pt_populatePartsList(string $name)
{
	string $node=pt_returnNodeFromName($name);
	string $elements[];
	string $mainlayout = "groups";
	string $layout = "parts";
	int $continue=1;
	if ($node == ""){
		iconTextCheckBox -e -v 0 -bgc .57 .62 .65 ("pt_"+$mainlayout+"_partsButton");
		$continue = 0;
		}
	if ($continue == 1){

		int $enable = `getAttr ($node+".partsEnable")`;
		if ($enable){
			string $elements[] = `listConnections ($node+".peltingComponentList")`;
			textScrollList -e -ra ("pt_pelt_elementList");
			textScrollList -e -a $elements[0] ("pt_pelt_elementList");
			iconTextCheckBox -e -v 1 -bgc .37 .52 .65 ("pt_"+$mainlayout+"_partsButton");
			}
		else
			iconTextCheckBox -e -v 0 -bgc .57 .62 .65 ("pt_"+$mainlayout+"_partsButton");
		
		iconTextButton -e -en $enable ("pt_pelt_"+$layout+"Button");
		frameLayout -e -m $enable -en $enable ("pt_pelt_"+$layout+"Frame");
		}
	
	
}

global proc pt_populateEdgeList(string $node)
{
	// string $node=pt_returnNodeFromName($name);
	string $sets[] = `listConnections ($node+".peltingEdgeList")`;
	textScrollList -e -ra pt_edgeList;
	textScrollList -e -a $sets[0] pt_edgeList;
}



//POPULATE STORED VERTEXES
global proc pt_populateVtxs(string $node)
{
	string $items[];
	string $sets[];
	string $match;
	string $name = `getAttr ($node+".peltingGroupName")`;
	// string $node=pt_returnNodeFromName($name);
	connectControl ("pt_enSVtxBox") ($node+".sVtxEnable");
	connectControl ("pt_enMVtxBox") ($node+".mVtxEnable");
	
	int $sEnable;
	int $mEnable;
	if (`getAttr ($node+".sVtxEnable")` == 1)
		$sEnable = 1;
	else 
		$sEnable = 0;
	
	if (`getAttr ($node+".mVtxEnable")` == 1)
		$mEnable = 1;
	else 
		$mEnable = 0;

		
	string $lists[] = {"pt_sVtxList","pt_eVtxList"};
	string $attrs[] = {"peltingStartVtx","peltingEndVtx"};

	for ($i=0;$i<2;$i++){
		textScrollList -e -ra $lists[$i];
		if (size(`listConnections ($node+"."+$attrs[$i])`)>0){	
			$sets = `listConnections ($node+"."+$attrs[$i])`;
			$items=`sets -q $sets[0]`;
			$match=`match ".vtx.+" $items[0]`;
			if ($match != "")
				$match=`substring $match 2 (size($match))`;
			textScrollList -e -a $match $lists[$i];
			}
		}
		
	string $sControls[]={"pt_sVtxButton","pt_sVtxList","pt_enMVtxBox","pt_eVtxButton","pt_eVtxList"};
	for ($sControl in $sControls)
		control -e -en $sEnable $sControl;		
	
	if ($sEnable == 1){
		string $mControls[]={"pt_eVtxButton","pt_eVtxList"};
		for ($mControl in $mControls)
			control -e -en $mEnable $mControl;
		}		
	
}


global proc pt_populateFrame(string $node)
{
	string $frames[] = `listConnections ($node+".peltingFrame")`;
	textScrollList -e -ra pt_frameList;
	textScrollList -e -a $frames[0] pt_frameList;
	floatFieldGrp -e -v1 (`getAttr ($node+".frameStrength")`) ("pt_frameField");
	floatFieldGrp -e -v1 ((`getAttr ($node+".meshStrength")`)/100.00) ("pt_meshField");
	intFieldGrp -e -v1 (`getAttr ($node+".walkLength")`) ("pt_lengthField");
}


global proc pt_populatePelt(string $node)
{
	string $layout = "simulation";
	string $grps[] = `listConnections ($node+".peltingGroup")`;
	textScrollList -e -ra pt_peltList;

	string $obj[]=`listConnections ($node+".peltingMesh")`;

	if (size($obj)>0){	
		textScrollList -e -a $grps[0] pt_peltList;
		string $particle[]=`listRelatives -ad -pa -type particle $obj[0]`;
		string $spring[]=`listConnections ($node+".peltingSpring")`;
		
		floatSliderGrp -e -v (`getAttr ($node+".frameStrength")`) ("pt_"+$layout+"_reFrameSpringField");
		floatSliderGrp -e -v ((`getAttr ($node+".meshStrength")`)/100) ("pt_"+$layout+"_reMeshSpringField");
		floatSliderGrp -e -v ((`getAttr ($node+".extraStrength")`)/100) ("pt_"+$layout+"_reExtraSpringField");
		
		floatFieldGrp -e -v1 (`getAttr ($node+".frameStrength")`) ("pt_frameField");
		floatFieldGrp -e -v1 ((`getAttr ($node+".meshStrength")`)/100) ("pt_meshField");
		intFieldGrp -e -v1 (`getAttr ($node+".walkLength")`) ("pt_lengthField");

		connectControl ("pt_"+$layout+"_dampField") ($particle[0]+".conserve");
		
		if (`getAttr ($node+".extraEnable")` == 1)
			frameLayout -e -cl 0 ("pt_"+$layout+"_extraFrame");
		else
			frameLayout -e -cl 1 ("pt_"+$layout+"_extraFrame");
		
		}
}


//POPULATE TEXTURE FILE
global proc pt_populateVisualisation(string $name)
{
	string $node = pt_returnNodeFromName($name);
	string $grps[] = `listConnections ($node+".peltingGroup")`;
	string $file = `getAttr ($node+".peltingTextureFile")`; 
	if ($file != "")
		textField -e -tx $file pt_imageField;
	
	pt_connectRepeatUVs({$name});
}

global proc pt_populateSimulation(string $name)
{
	string $node = pt_returnNodeFromName($name);
	string $peltingMesh[] = `listConnections ($node+".peltingMesh")`;
	string $particles[] = `listRelatives -ad -pa -type particle $peltingMesh`;
	if (size($particles)>0){
		if (`getAttr ($particles[0]+".isDynamic")` == 1)
			iconTextCheckBox -e -v 0 -l "LOCK PELT" pt_lockPeltButton;
		else
			iconTextCheckBox -e -v 1 -l "UNLOCK PELT" pt_lockPeltButton;
		}
	else
		iconTextCheckBox -e -v 0 -l "LOCK PELT" pt_lockPeltButton;
	
	
}


//**************************************************************************
//
//				PELTING PROC
//
//**************************************************************************


//PELT MESH
global proc int pt_peltMesh(int $bypass, string $type)
{
	$start =`timerX`;
	//	declared variables
	//
	int $walkLength;
	
	string $framePart[2];
	string $matchA;
	string $matchB;
	float $rPS;
	string $sVtxs[];
	string $curve;
	string $sVtx;
	string $eVtx;
	string $frame;
	string $edges[];
	string $oEdges[];
	string $set[3];
	string $oldObj;
	int $continue = 1;
	string $elementList;
	//string $addSpring[];
	//float $sDist[];
	//float $eDist=0.00;



	//	name of pelting group
	//
	string $names[] = `textScrollList -q -si pt_pelt_groupList`;
	string $name = $names[0];
	string $node = pt_returnNodeFromName($names[0]);
	
	//	checks
	//
	int $continuity = `getAttr ($node+".continuity")`;

	if ($continuity == 0){
		warning "Enter Continuous Edges First!";
		$continue = 0;
		}

	//	check for parts
	//	
	int $parts = pt_returnPartsEnabled($node);
	int $reuse = `getAttr ($node+".partsReuse")`;
	
	if ($parts == 1)
		$elementList =pt_returnFirstItemInList(`listConnections ($node+".peltingComponentList")`);

	
	//	if high walk length
	//
	int $wLength = `intFieldGrp -q -v1 pt_lengthField`;
	if ($wLength > 3)
		if ($bypass == 0)
			if ((`confirmDialog -title "Walk Length Alert!" -message ("Do you really want to use a walkLength of "+$wLength+"?  Will take some time to calculate...") -button "Proceed" -button "No - let me enter a different value"  -defaultButton "No - let me enter a different value" -cancelButton "No - let me enter a different value" -dismissString "No - let me enter a different value"`)=="No - let me enter a different value")
				$continue = 0;

	//	old pelt check
	//	
	string $peltingSpring[] = `listConnections ($node+".peltingSpring")`;
	if (size($peltingSpring) > 0){
		warning "Delete Old Pelt First!";
		$continue = 0;
		}

	//	frame name
	//
	string $frames[]=`listConnections ($node+".peltingFrame")`;
	if (size($frames)>0)
		$frame = $frames[0];
	else{
		warning "Create Frame First";
		$continue = 0;
		}
		
	//	check for edge list components
	//
	string $edgeList = pt_returnFirstItemInList(`listConnections ($node+".peltingEdgeList")`);
	if ($edgeList != ""){
		string $edgeSet[] = `sets -q $edgeList`;
		if (size($edgeSet) == 0){
			warning "Enter Edge List First";
			$continue = 0;
			}
		}
		
	
	//	condition: old pelt is already deleted, frame is created, etc
	//	
	if ($continue == 1){
		//	ORIGINAL SETS - Edge Set, sVtx Set, eVtx Set
		//
		$set[0]=pt_returnFirstItemInList(`textScrollList -q -ai pt_edgeList`);

		//	get starting and ending vertex
		//		
		$set[1]=pt_returnFirstItemInList(`listConnections ($node+".peltingStartVtx")`);
		$set[2]=pt_returnFirstItemInList(`listConnections ($node+".peltingEndVtx")`);		
		
		
/* 		string $set[1]=pt_returnFirstItemInList(`textScrollList -q -ai pt_edgeList`);
		string $edgeSet = $set[0];

		//	get starting and ending vertex
		//		
		$sets=`listConnections ($node+".peltingStartVtx")`;
		string $sVtxSet=$sets[0];
		$sets=`listConnections ($node+".peltingEndVtx")`;
		string $eVtxSet=$sets[0];
 */		
		if ($set[1] != "")
			$sVtx = pt_returnFirstItemInList(`sets -q $set[1]`);
		if ($set[2] != "")
			$eVtx = pt_returnFirstItemInList(`sets -q $set[2]`);
		
		
				
		
		//	objs from node attrs
		//
		string $obj = pt_returnFirstItemInList(`listConnections ($node+".peltingMesh")`);
		string $grp = pt_returnFirstItemInList(`listConnections ($node+".peltingGroup")`);
		string $original = pt_returnFirstItemInList(`listConnections ($node+".peltingOriginal")`);


		string $shape = pt_returnFirstItemInList(`listRelatives -s $obj`);
		int $vCnt = `getAttr -s ($shape+".vrts")`;
		// string $vtxString = `polyEvaluate -v -fmt $obj`;
		// int $counts[];
		// $counts[0] = int(`match "[0-9].+" $vtxString`);


		//	vertex conversion
		//
		//	edges from list
		//
		string $vtxs[]=`ls -fl (eval("sets -q "+$set[0]+""))`;
		// string $lVtxs[]=`polyListComponentConversion -fe -tv $edges`;
		// string $vtxs[]=`filterExpand -sm 31 $lVtxs`;
		if (`getAttr ($node+".sVtxEnable")` == 0)
			$sVtx = $vtxs[0];
			
		if (`getAttr ($node+".mVtxEnable")` == 0)
			$eVtx = "";

		//	get sorted vtxs (sort vertices along seam)
		//
		undoInfo -swf 0;
		$sVtxs=pt_sortVerts($vtxs, $sVtx);
		undoInfo -swf 1;
		
		//	condition: if start vertex lies on seam
		//
		if (stringArrayCount($sVtx,$vtxs)>0){

			//	set object normals back to soft and unlock
			//
			if ($parts == 1){
				if ($reuse == 0){
					polyNormalPerVertex -ufn 1 ($obj+".vtxFace[0:"+$vCnt+"]");
					polySoftEdge -a 180 -ch 0 $obj;
					}
				}
			else{
				polyNormalPerVertex -ufn 1 ($obj+".vtxFace[0:"+$vCnt+"]");
				polySoftEdge -a 180 -ch 0 $obj;
				}
			
			polyOptions -cs 0 $obj;
			
			//	toggle visibility group
			pt_toggleVis($node,1);
		
			//	create texture duplicate
			//
			string $textureMesh[]=`duplicate -n ($name+"_textureMesh") $original`;
			

			//	create particle frame
			//
			if ($type == ""){
				if (`menuItem -q -rb pt_pelt_distanceItem`)
					$type = "free";
				else
					$type = "even";
				}
			else{
				if ($type == "world")
					$type = "free";
				else
					$type = "even";
				}
			
			$framePart=eval(pt_makeFrameParticles($sVtxs,$frame,$obj,$eVtx,$type));
			parent $framePart[0] $frame;
	

			//	softbody particles
			//
			string $soft[]=`soft -c $obj`;			
	
	
			//	get walk length
			//
			$walkLength = `intFieldGrp -q -v1 pt_lengthField`;

			
			int $elementSize;
			
			//	create spring on whole obj - slows down on selected springs...
			//
			if ($parts == 1){
				$elementSize = size(`sets -q $elementList`);
				if ($vCnt/2 > $elementSize)
					select $elementList;
				else
					select $obj;
				}
			else
				select $obj;
			
			string $spring[2]=`spring -n  ($frame+"Springs") -wf 1 -wl $walkLength -usp 1 -urp 1`;
			
			string $frameSpringShape = `createNode spring`;
			string $frameSpring=`rename (eval("listRelatives -p "+$frameSpringShape)) ($frame+"FrameSprings")`;

			addAttr -ln frameStrength -at double -min 0 $spring[0];
			addAttr -ln sCnt -at double -min 0 $spring[0];
			addAttr -ln sVtxs -at double -min 0 $spring[0];
			addAttr -ln meshStrength -at double -min 0 $spring[0];
			addAttr -ln walkLength -at double -min 0 $spring[0];
			addAttr -ln conserve -at double -min 0 $spring[0];
			
			int $sCnt=`getAttr ($spring[0]+".count")`;
			//int $sValue=1000;
			//int $bValue=100;
	
			
			// int $sValue=1000/`floatFieldGrp -q -v1 pt_frameField`;
			float $sValue = `floatFieldGrp -q -v1 pt_frameField`;
			float $bValue=`floatFieldGrp -q -v1 pt_meshField`*100;
			
			
			setAttr ($node+".sCnt") $sCnt;
			setAttr ($node+".frameStrength") $sValue;
			setAttr ($node+".sVtxs") (size($sVtxs));
			setAttr ($node+".meshStrength") $bValue;
			setAttr ($node+".walkLength") $walkLength;
			
			undoInfo -swf 0;
			pt_setBodyWeights($spring[0],$bValue,$sCnt);
			pt_setFrameSprings($sCnt, $sVtxs,$frameSpring, $soft[0], $framePart[0],$sValue);
			undoInfo -swf 1;
	
			//	switch off is dynamic
			//
			setAttr ($framePart[0]+".isDynamic") 0;
		
			//	turn down conserve
			//
			setAttr ($soft[0]+".conserve") .970;
	
			string $particles[]=`listRelatives -ad -pa -type particle $obj`;
			if (`objExists ($frame+"Grp")`)
				delete ($frame+"Grp");
			
			
			connectAttr -f ($spring[0]+".message") ($node+".peltingSpring");
			connectAttr -f ($frameSpring+".message") ($node+".peltingFrameSpring");
			connectAttr -f ($textureMesh[0]+".message") ($node+".peltingTextureMesh");
			
			
			// connectAttr -f ($grp+".visibility") ($soft[0]+".isDynamic");
			connectAttr -f ($grp+".visibility") ($soft[0]+".dynamicsWeight");
			connectAttr -f ($grp+".visibility") ($soft[0]+".forcesInWorld");
			
			parent $textureMesh[0] $spring[0] $frameSpring $grp;
			setAttr ($obj+".visibility") 1;
			setAttr ($spring[0]+".visibility") 0;
			setAttr ($particles[0]+".visibility") 0;
			
			
			pt_populatePelt($node);
	
			//	assign shader to texture obj and initial object
			//
			if (`textField -q -tx pt_imageField`!="")
				pt_applyImageToDuplicate (`textField -q -tx pt_imageField`, "image");
			
			if ($parts == 0){
				if (`objExists initialShadingGroup`){
					string $lamberts[]=`listConnections initialShadingGroup.surfaceShader`;
					select $obj;
					hyperShade -assign $lamberts[0];
					}
				}
			
			//	apply planar projection and transfer uvs to texture mesh
			//
			string $md=pt_getPeltAxis($frame);
			
			int $cnt=`getAttr -s ($shape+".face")`;

			// undoInfo -swf 0;
			// if ($parts == 1){
				// select $elementList;
				// select (`polyListComponentConversion -fv -tf $elementList`);
				// }
			// else

			if ($parts == 1){
				select $elementList;
				select (`polyListComponentConversion -fv -tf`);
				}
			else
				select ($obj+".f[0:"+$cnt+"]");
			// undoInfo -swf 1;

			//	This is causing the major slowdown...
			//
			// string $proj[] = `polyPlanarProjection -icx (0.5+`getAttr ($node+".partsRegion")`) -icy 0.5 -sf 1 -md $md`;
			//delete $proj;
			// pt_setLockedNode("delete -ch "+$obj,$obj);
			polyPlanarProjection -icx (0.5+`getAttr ($node+".partsRegion")`) -icy 0.5 -sf 1 -md $md;
			// polyProjection -ch 1 -type Planar -ibd on -icx (0.5+`getAttr ($node+".partsRegion")`) -icy 0.5 -ra 0 -isu 1 -isv 1 -sf 1 -md $md;
			polyTransfer -vc 0 -uv 1 -v 0 -ao $obj $textureMesh[0];
			
			//	move textured mesh out in front
			//
			// showHidden ($textureMesh[0]);
			float $bBox[6]=`exactWorldBoundingBox $textureMesh[0]`;
			float $bCenter[3] = {($bBox[0] + $bBox[3])/2,($bBox[1] + $bBox[4])/2,($bBox[2] + $bBox[5])/2};
			float $bSize[3] = {abs($bBox[3] - $bBox[0]),abs($bBox[4] - $bBox[1]),abs($bBox[5] - $bBox[2])};
			float $bSize[3] = `sort($bSize)`;  

			// float $bBoxes[3] = `getAttr ($textureMesh[0]+".boundingBoxSize")`;
			// float $bBoxMove[3] = `sort ($bBoxes)`;			
			string $mcmd = "move -r ";
			string $axes[3] = {"x","y","z"};
			for ($i=0;$i<3;$i++)
				if ($md == $axes[$i])
					$mcmd +=(2*$bSize[0])+" ";
				else
					$mcmd +="0 ";			
				
			$mcmd += " "+$textureMesh[0];
			eval($mcmd);
			hide $textureMesh[0] $original;
			
			// if ($parts == 1){
				// if ($reuse == 0){
					// string $cluster[]=`cluster $obj`;
					// delete $cluster;
			// // polySoftEdge -a 180 -ch 0 $obj;
					// polyNormalPerVertex -fn 1 ($obj+".vtxFace[0:"+$counts[0]+"]");
					// }
				// }
			// else{
			string $cluster[]=`cluster $obj`;
			delete $cluster;
			if ($reuse == 0)
				polyNormalPerVertex -fn 1 ($obj+".vtxFace[0:"+$vCnt+"]");
			if (($parts == 1)&&($reuse == 1))
				polyNormalPerVertex -ufn 1 ($obj+".vtxFace[0:"+$vCnt+"]");
				// }
				
			pt_toggleModelViews({$name}, "none");				

			
			//	set interface checks
			//
			setAttr ($node+".simulationEnable") 1;
			setAttr ($node+".visualisationEnable") 1;
		//set obj texture
/* 			string $dShader=`shadingNode -asShader lambert`;
			$dShader=`rename $dShader ($frame+"DefaultTexture")`;
			select -r $obj;
			hyperShade -assign $dShader;
 */
			pt_setManageState(pt_returnManageStates("Specific",$node));
			// pt_selectPeltGrp(`textScrollList -q -si pt_peltList`);
			print (`timerX -st $start`);
			return 1;
			}
			
		else if ((stringArrayCount($sVtx,$vtxs)==0)||(stringArrayCount($eVtx,$vtxs)==0)){
			// showHidden $oldObj;
			// delete $dup[0];
	
			warning "Your startVertex is not in your edge selection";
			return 0;	
			}
		clear $edges;
		}
	return 0;
	select -cl;
}



//MAKE FRAME PARTICLES
global proc string pt_makeFrameParticles(string $sVtxs[],string $frame,string $obj,string $eVtx, string $type)
{
	float $sDist[];
	float $dist1=0.000000;
	float $dist2=0.000000;
	string $pPos;
	float $pos[3];
	float $apos[3];
	float $cPos[3];
	float $epos[3];
	//float $dpos[3];
	float $uparam=0.000000;
	float $sorted[3];
	float $bBox[3];
	float $axis[3];
	string $type;
	int $switch;

//string to make particle frame
	$pPos=("particle -n "+$obj+"frameParticles");
/* 	if ($eVtx == "")
		$type = "free";
	else
		$type = "vtx";
 */
//determine edge lengths
	switch ($type){
		case "vtx":
			//	these are the total $dist1 and $dist2 lengths
			//
			for ($i=0;$i<size($sVtxs);$i++){
				//vtx position
				//
				$pos=`pointPosition $sVtxs[$i]`;
				if ($i<size($sVtxs)-1)
					$cPos=`pointPosition ($sVtxs[$i+1])`;
				else 
					$cPos=`pointPosition ($sVtxs[0])`;
		
				if ($sVtxs[$i]==$eVtx)
					$switch=1;
				$sDist[$i]=`mag<<$pos[0]-$cPos[0],$pos[1]-$cPos[1],$pos[2]-$cPos[2]>>`;		
				if ($switch==0)
					$dist1=$dist1+$sDist[$i];
				else if ($switch==1)
					$dist2=$dist2+$sDist[$i];
				}
					
			$switch=0;
			//	find curve positions for outer edge
			//
			for ($i=0;$i<size($sVtxs);$i++){
			//find svtx position
				$pos=`pointPosition $sVtxs[$i]`;
				if ($i==0){
				//eVtx position
					$epos=`pointPosition $eVtx`;
				//vector from start to end		
					$pos={$pos[0]-$epos[0],$pos[1]-$epos[1],$pos[2]-$epos[2]};			
				//make values abs
					$apos={`abs $pos[0]`,`abs $pos[1]`,`abs $pos[2]`};
				//frame bounding box size			
					$bBox=`getAttr ($frame+".boundingBoxSize")`;
				//sort smallest -> biggest						
					$axis=`sort $bBox`;
				//find smallest frame bBox vector (x,y, or z) and "zero" that vector for the $apos
					for ($j=0;$j<3;$j++){
						if ($bBox[$j]==$axis[0])
							$apos[$j]=0;
						}
				//find smallest -> largest $apos
					$sorted=`sort $apos`;
				//make rest into zeros
					for ($j=0;$j<3;$j++){
					//normalize between 0 and $sorted[2]
						$apos[$j]=linstep(0,$sorted[2],$apos[$j])	;
						if ($apos[$j]!=1)
							$apos[$j]=0;
						if (($apos[$j]==1)&&($apos[$j]!=($pos[$j]/abs($pos[$j]))))
							$apos[$j]=-$apos[$j];				
						}
		
					//find closest curve point for first spring
					//
					$uparam=`closestPointOnCurve -ip ($apos[0]*$bBox[0]) ($apos[1]*$bBox[1]) ($apos[2]*$bBox[2]) -q -u $frame`;
					}
				
				else {
					if ($sVtxs[$i]==$eVtx)
						$switch=1;
					if ($switch==0)
						$uparam=$uparam+(($sDist[$i-1]/$dist1)*.5);
					else if ($switch==1)
						$uparam=$uparam+(($sDist[$i-1]/$dist2)*.5);
				
					if ($uparam>1)
						$uparam=$uparam-1;
					}
				$cPos=`pointOnCurve -pr $uparam $frame`;
				
				//print ($uparam+"\n");
			//set particle at point
				$pPos=$pPos+" -p "+$cPos[0]+" "+$cPos[1]+" "+$cPos[2];		
				}
			break;
		case "free":
			
			for ($i=0;$i<size($sVtxs);$i++){
			//vtx position		
				$pos=`pointPosition $sVtxs[$i]`;
				if ($i<size($sVtxs)-1)
					$cPos=`pointPosition ($sVtxs[$i+1])`;
				else 
					$cPos=`pointPosition ($sVtxs[0])`;
		
				$sDist[$i]=`mag<<$pos[0]-$cPos[0],$pos[1]-$cPos[1],$pos[2]-$cPos[2]>>`;		
				$dist1=$dist1+$sDist[$i];
				}
			for ($i=0;$i<size($sVtxs);$i++){
			//find svtx position
				$pos=`pointPosition $sVtxs[$i]`;
				if ($i==0){
					$uparam = 0;
					}
				
				else {
					$uparam=$uparam+(($sDist[$i-1]/$dist1));
					}
				$cPos=`pointOnCurve -pr $uparam $frame`;
		
				$pPos=$pPos+" -p "+$cPos[0]+" "+$cPos[1]+" "+$cPos[2];		
				}
			break;
		case "even":
			float $num = size($sVtxs);
			for ($i=0;$i<size($sVtxs);$i++){
				$uparam=$i/$num;				
				$cPos=`pointOnCurve -pr $uparam $frame`;
				$pPos=$pPos+" -p "+$cPos[0]+" "+$cPos[1]+" "+$cPos[2];
				}
			break;

		}

return $pPos;
}


//BODY WEIGHTS
global proc pt_setBodyWeights(string $spring, float $v, int $sCnt)
{
	spring -e -sPS ($v) $spring;
}



//SPRING WEIGHTS
global proc pt_setFrameSprings(int $sCnt, string $sVtxs[],string $spring, string $soft, string $framePart,float $sValue)
{
int $size=`size($sVtxs)`;
progressWindow -title "Setting Frame Weights" -progress 0 -max (`size($sVtxs)`) -status "Spring Count: ";
//add springs to the outer circle
for ($i=0;$i<size($sVtxs);$i++){
//matching the number
	int $id=pt_getIndexFromComponent($sVtxs[$i]);
//add spring
	spring -add -all true -noDuplicate false ($soft+".pt["+$id+"]") ($framePart+".pt["+$i+"]") $spring;

//set frame spring with small stiffness and zero restlength...	
	spring -e -rPS (0.0001) -sPS $sValue ($spring+".sp["+$sCnt+"]");
	$sCnt=$sCnt+1;	

	progressWindow -edit -progress $i -status ("Spring Count: "+$i+" out of "+$size);
	}
progressWindow -endProgress;
}


global proc pt_setParticleRestLength(string $spring, string $particle)
{
	
/* addAttr -ln restLengthPP0 -dt doubleArray  lizard_PeltingMeshParticleShape;
addAttr -ln restLengthPP -dt doubleArray  lizard_PeltingMeshParticleShape;
setAttr -e -keyable true lizard_PeltingMeshParticleShape.restLengthPP;
addAttr -ln goalPP0 -dt doubleArray  lizard_PeltingMeshParticleShape;
addAttr -ln goalPP -dt doubleArray  lizard_PeltingMeshParticleShape;
setAttr -e -keyable true lizard_PeltingMeshParticleShape.goalPP;
	
	
string $part = "torus_PeltingMeshParticleShape";
string $spring = "torus_FrameSpringsShape";
int $pCnt = `getAttr ($part+".count")`;
for ($i=0;$i<$pCnt;$i++)
	particle -e -attribute restLength -id $i -fv (`spring -q -rPS ($spring+".sp["+$i+"]")`) $part;
	
{
$start = `timerX`;
string $part = "lizard_PeltingMeshParticleShape";
string $spring = "lizard_FrameSpringsShape";
int $pCnt = `getAttr ($part+".count")`;
float $rest[]= `getAttr ($part+".restLengthPP")`;
float $goal[]= `getAttr ($part+".goalPP")`;
for ($i=0;$i<$pCnt;$i++){
	spring -e -rPS ($rest[$i]*$goal[$i]) ($spring+".sp["+$i+"]");
	}

print (`timerX -startTime 1`);
}


int $id = torus_PeltingMeshParticleShape.particleId;
string $spring = "torus_FrameSpringsShape";
float $weight = 2*torus_PeltingMeshParticleShape.goalPP - 1;

dynExpression -s "int $id = torus_PeltingMeshParticleShape.particleId;\r\nstring $spring = \"torus_FrameSpringsShape\";\r\nfloat $weight = 2*torus_PeltingMeshParticleShape.goalPP - 1;\r\n\r\nspring -e -rPS ($weight * torus_PeltingMeshParticleShape.restLength) ($spring+\".sp[\"+$id+\"]\");" -c torus_PeltingMeshParticleShape;


spring -e -rPS ($weight * torus_PeltingMeshParticleShape.restLength) ($spring+".sp["+$id+"]");	
 */	
	
	
}

//RESPRING PROC
global proc pt_reSpringStrength(string $names[], float $re_sValue, string $type)
{
	string $node = pt_returnNodeFromName($names[0]);
	
	//	check for groups in field
	//
	if (size($node) != ""){
		// int $sCnt=`getAttr ($node+".sCnt")`;
		
		
		switch ($type){
			case "Frame":
				string $spring[0]=`listConnections ($node+".peltingFrameSpring")`;
				if ($spring[0] != ""){
					int $sCnt = `getAttr ($spring[0]+".count")`;
					int $sVtxs=`getAttr ($node+".sVtxs")`;
					float $div=1000/$re_sValue;
					spring -e -sPS $re_sValue ($spring[0]+".sp[0:"+($sCnt-1)+"]");
					setAttr ($node+".frameStrength") $re_sValue;
					}
				break;
			case "Mesh":
				string $spring[0]=`listConnections ($node+".peltingSpring")`;
				if ($spring[0] != ""){
					int $sCnt=`getAttr ($node+".sCnt")`;
					// int $sCnt = `getAttr ($spring[0]+".count")`;
					float $div=100*$re_sValue;
					spring -e -sPS ($re_sValue*100) ($spring[0]+".sp[0:"+($sCnt-1)+"]");
					
					setAttr ($node+".meshStrength") $div;
					}
				break;
			case "Extra":
				string $spring[0]=`listConnections ($node+".peltingSpring")`;
				if ($spring[0] != ""){
					int $nCnt=`getAttr ($node+".sCnt")`;
					int $sCnt = `getAttr ($spring[0]+".count")`;
					float $div=100*$re_sValue;
					spring -e -sPS ($re_sValue*100) ($spring[0]+".sp["+($nCnt-1)+":"+($sCnt-1)+"]");
					setAttr ($node+".extraStrength") $div;
					}
				break;
				
			}
		print ($type+" Springs Successfully Changed");
		pt_populateFrame($node);
		}
	
}






//SET START/END VERTEX
global proc pt_setVertexList(string $vtxs[],string $name, string $list,string $type)
{
	string $node = pt_returnNodeFromName($name);
	string $edgeSets[] = `textScrollList -q -ai pt_edgeList`;
	string $eVtxs[]=`sets -q $edgeSets[0]`;
	$eVtxs = `ls -fl $eVtxs`;
	

if ((size($vtxs)==1)&&(size($eVtxs)>0)){
//edges
	// string $lVtxs[]=`polyListComponentConversion -fe -tv $edges`;
//verts
	// string $eVtxs[]=`filterExpand -sm 31 $lVtxs`;

	if (stringArrayCount($vtxs[0],$eVtxs)==0){
		warning "Vertex does not lie in Edge List";
		}
	else {
		string $objs[];
		$objs=`ls -hl`;
		string $node=pt_returnNodeFromName($name);
		string $vSets[] = `listConnections ($node+".pelting"+$type)`;

 		if ($vSets[0] != "")
			pt_setLockedNode(("delete "+$vSets[0]+""),$vSets[0]);
			// delete $vSets[0];
		select $vtxs;
		string $set=`sets -v 1 -co 0 -n $vSets[0]`;
		connectAttr -f ($set+".message") ($node+".pelting"+$type);
		// addAttr -ln ("pelting_"+$setName+"Set") -dt "string" ("pelting_"+$setName);
		// setAttr -type "string" ("pelting_"+$setName+".pelting_"+$setName+"Set") $objs[0];
		pt_populateVtxs($node);
		lockNode $set;

		// textScrollList -e -ra $list;
		
		// textScrollList -e -a $vtxs[0] $list;
		// pt_getStoredVtxs(`ls -type objectSet`);
		// pt_createVertexConstraint($vtxs, $setName,$objs);
		}

	}
else {
	warning "Select One Vertex! and/or Enter Edge List First!";
	}
}



global proc string[] pt_listFrames(string $curves[])
{
string $parent[1];
string $frames[];
for ($curve in $curves){
	$parent=`listRelatives -p $curve`;
	if (`objExists ($parent[0]+".peltingFrame")`)
		$frames[size($frames)]=$parent[0];
	}
return $frames;
}

//LIST STORED FRAMES
global proc pt_getStoredFrames(string $curves[])
{
textScrollList -e -ra pt_frameList;
string $frames[]=pt_listFrames($curves);
for ($frame in $frames)
	textScrollList -e -a $frame pt_frameList;

}




global proc pt_postPopupCmd(string $frames[],float $bBox[])
{
int $switch=0;
float $sorted[3]=`sort $bBox`;
string $axes[3]={"X","Y","Z"};
for ($i=0;$i<3;$i++){
	if ($bBox[$i]==$sorted[0])
		$axes[$i]="";
	}

for ($axis in $axes){
	if (($axis!="")&&($switch==0)){
		menuItem -e -l ("Flip along "+$axis+"-Axis...") -c ("setAttr  (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scale"+$axis+"\") (-1*(`getAttr (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scale"+$axis+"\")`))") pt_flipHItem;	
		menuItem -e -l ("Rotate 90 "+$axis+"-Axis...") -c ("setAttr  (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".rotate"+$axis+"\") ((`getAttr (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".rotate"+$axis+"\")`)+90)") pt_rotateHItem;	
		$switch=1;
		}
	else if (($axis!="")&&($switch==1)){
		menuItem -e -l ("Flip along "+$axis+"-Axis...") -c ("setAttr  (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scale"+$axis+"\") (-1*(`getAttr (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scale"+$axis+"\")`))") pt_flipVItem;	
		menuItem -e -l ("Rotate 90 "+$axis+"-Axis...") -c ("setAttr  (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".rotate"+$axis+"\") ((`getAttr (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".rotate"+$axis+"\")`)+90)") pt_rotateVItem;	
		}
	}
//setAttr ($frames[0]+"."+$axis) (-1*(`getAttr ($frames[0]+"."+$axis)`));
}


global proc string pt_getPeltAxis(string $frame)
{
string $md;
float $bBox[3]=`getAttr ($frame+".boundingBoxSize")`;
float $axis[3]=`sort $bBox`;
string $a[3]={"x","y","z"};
for ($i=0;$i<3;$i++){
	if ($bBox[$i]==$axis[0]){
		$md=$a[$i];	
		
		}
	}
return $md;
}




//GET STARTING VERTEX
global proc string pt_getEndVertex(string $vtxs[],string $edges[])
{
	string $fVtxs[];	
	string $nVtxs[];
	float $pos[3];
	vector $nVects[];
	float $mags[];
	string $eVtxs[];
	int $int=5;
	//loop through vertices
	//for ($i=0;$i<(size($vtxs));$i++){
	for ($i=$int;$i<$int+1;$i++){
		$fVtxs=pt_getSurrVtxs($vtxs[$i]);
		
		for ($fVtx in $fVtxs){
			if ((stringArrayCount($fVtx, $vtxs)>0)&&($fVtx!=$vtxs[$i])){
				$nVtxs[size($nVtxs)]=$fVtx;
				}
			}
		//select $nVtxs;
		for ($nVtx in $nVtxs){
			$pos=`pointPosition $nVtx`;
			//print $pos;
			//$nVects[size($nVects)]=<<$pos[0],$pos[1],$pos[2]>>;
			$mags[size($nVects)]=<<$pos[0],$pos[1],$pos[2]>>;
			//print ($nVects[size($nVects)]);
			}
		if (size($nVects)>1){
			if ($nVects[0]=$nVects[1]){
				$eVtxs[size($eVtxs)]=$vtxs[$i];
				//select $eVtxs;
				}
			}
		
		clear $nVtxs;
		clear $fVtxs;
		clear $nVtxs;
		}
	//print $eVtxs;
	return $eVtxs[0];

	//return "here";
	
}


//SORT VERTICES AROUND SEAM
global proc string[] pt_sortVerts(string $vtxs[], string $sVtx)
{
	string $fVtxs[];
	string $nVtxs[];

//vtxs start at $sVtx
	$nVtxs[0]=$sVtx;
	int $size=`size($vtxs)`;
	progressWindow -title "Sorting Through Edges" -progress 0 -max (`size($vtxs)`) -status ("Edge Count: ");
	for ($i=1;$i<(size($vtxs));$i++){
		if (`objExists $nVtxs[$i-1]`){
			$fVtxs=pt_getSurrVtxs($nVtxs[$i-1]);		
			
		//get vtx not already in list and on edge
			for ($fVtx in $fVtxs){		
				if ((stringArrayCount($fVtx,$vtxs)>0)&&(stringArrayCount($fVtx, $nVtxs)<1)){
					$nVtxs[$i]=$fVtx;
					break;
					}
				}
			if (($nVtxs[$i]=="")&&($i!=size($vtxs)-1)){	
				break;
				}
			}
		progressWindow -edit -progress $i -status ("Edge Count: "+$i+" out of "+$size);
		}
	progressWindow -endProgress;
return $nVtxs;
}


global proc string[] pt_getSurrVtxs(string $vtx)
{
	string $lEdges[10];
	string $lVtxs[10];
	string $fVtxs[10];

	//convert to edges
		$lEdges=`polyListComponentConversion -fv -te $vtx`;
	
	//convert to vtxs
		$lVtxs=`polyListComponentConversion -fe -tv $lEdges`;
	
	//flatten vtxs
		$fVtxs=`ls -fl $lVtxs`;
//clear $lEdges;
//clear $lVtxs;
//clear $fVtxs;
return $fVtxs;
}




//**************************************************************************
//ALL THE STUFF TO DO WITH TEXTURING THE PELT TEXTURE MESH
//**************************************************************************
global proc string pt_applyImageToDuplicate(string $file, string $type)
{
	string $shader;
	switch ($type){
		case "image":
			int $play = `play -q -state`;
			if ($play)
				play -state 0;
			string $names[] = `textScrollList -q -si pt_pelt_groupList`;
			string $node = pt_returnNodeFromName($names[0]);

			string $layout = "visualisation";
			setAttr -type "string" ($node+".peltingTextureFile") $file;
			textField -e -tx $file ("pt_imageField");
			
			string $textureMesh[]=`listConnections ($node+".peltingTextureMesh")`;
			string $pShaders[] = `listConnections ($node+".peltingShader")`;
			string $original[] = `listConnections ($node+".peltingOriginal")`;
			
			if (size($pShaders) > 0){
				string $list[] = `listHistory ($pShaders[0])`;
				delete (`listConnections -type shadingEngine ($pShaders[0])`);
				for ($item in $list)
					if ($item != $node)
						delete $item;
				}
			
			//	get old shader and delete
			//
			if (`objExists ($names[0]+"_PeltingShader")`){
				string $list[] = `listHistory ($names[0]+"_PeltingShader")`;
				delete (`listConnections -type shadingEngine ($names[0]+"_PeltingShader")`);
				for ($item in $list)
					if ($item != $node)
						delete $item;
				}

			//	if texture mesh doesn't exist, then apply to original object
			//
			if (size($textureMesh) == 0){
				string $fileTex;
				//	if peltingShader already exists, discover file texture 
				if (`objExists ("PeltingShader")`){
					$shader = "PeltingShader";
					string $list[] = `listHistory ("PeltingShader")`;
					for ($item in $list)
						if (`nodeType $item` == "file")
							$fileTex = $item;
					}
				//	else make the shader
				//
				else{
					$shader=`shadingNode -asShader lambert`;
					$shader=`rename $shader ("PeltingShader")`;
					}
				//	if there is no previously defined fileTex, make one
				//
				if ($fileTex == ""){	
					$fileTex=renderCreateNode("-as2DTexture", "", "file", "",0, 0, 1, 1,0, "");
					connectAttr -f ($fileTex+".outColor") ($shader+".color");
					}
				
				setAttr -type "string" ($fileTex+".fileTextureName") $file;
				string $placement[]=`listConnections -type place2dTexture $fileTex`;
				setAttr ($placement[0]+".repeatU") 4;
				setAttr ($placement[0]+".repeatV") 4;
				select -r $original[0];
				hyperShade -assign $shader;
				select -cl;
				}

			else{
				string $fileTex=renderCreateNode("-as2DTexture", "", "file", "",0, 0, 1, 1,0, "");
				$shader=`shadingNode -asShader lambert`;
		
				$shader=`rename $shader ($names[0]+"_PeltingShader")`;
			
				connectAttr -f ($shader+".message") ($node+".peltingShader");
				
				connectAttr -f ($fileTex+".outColor") ($shader+".color");
				setAttr -type "string" ($fileTex+".fileTextureName") $file;
				//AEassignTextureCB ($fileTex+".fileTextureName") $file "image";
				
				string $places[]=`listConnections -type place2dTexture $fileTex`;
		
				connectAttr -f ($node+".peltingU") ($places[0]+".repeatU");
				connectAttr -f ($node+".peltingV") ($places[0]+".repeatV");
				connectControl ("pt_"+$layout+"_uField") ($node+".peltingU");
				connectControl ("pt_"+$layout+"_vField") ($node+".peltingV");
				
		
				select -r $textureMesh;
				hyperShade -assign $shader;
				select -cl;
				}
			if ($play)
				play;

			break;
		case "General":
			if (!`objExists ("PeltingShader")`){
				string $fileTex=renderCreateNode("-as2DTexture", "", "file", "",0, 0, 1, 1,0, "");
				$shader=`shadingNode -asShader lambert`;
				$shader=`rename $shader ("PeltingShader")`;
				connectAttr -f ($fileTex+".outColor") ($shader+".color");
				setAttr -type "string" ($fileTex+".fileTextureName") $file;
				string $placement[]=`listConnections -type place2dTexture $fileTex`;
				setAttr ($placement[0]+".repeatU") 4;
				setAttr ($placement[0]+".repeatV") 4;
				}
			else
				$shader = "PeltingShader";
			break;
		}
	return $shader;
}

//Check to see if pelt group is available
global proc pt_openTextureBrowser(string $sel[])
{
if ($sel[0]!="")
	fileBrowserDialog -m 0 -fc "pt_applyImageToDuplicate" -ft "image" -an "Open Texture Image" -om "Open";	
//	AEfileTextureBrowser "pt_applyImageToDuplicate";
else
	warning "Select Pelting Group First!";
}


global proc pt_connectRepeatUVs(string $names[])
{
	if (size($names)>0){
		string $node = pt_returnNodeFromName($names[0]);
		connectControl pt_visualisation_uField ($node+".peltingU");
		connectControl pt_visualisation_vField ($node+".peltingV");
		}
}

global proc pt_toggleModelViews(string $names[], string $type)
{
	string $node = pt_returnNodeFromName($names[0]);
	
	if ($node != ""){
		string $meshes[] = `listConnections ($node+".peltingMesh")`;
		string $list[] = `listHistory $meshes[0]`;
		int $vis[];	
		switch($type){
			case "checker":
				string $panel = `getPanel -withFocus`;
				if (`getPanel -to $panel` ==  "modelPanel") 
					if (`modelEditor -q -dtx $panel` != 1)
						modelEditor -e -da "smoothShaded" -displayTextures on $panel;
				string $checkerMesh =pt_returnFirstItemInList(`listConnections ($node+".peltingTextureMesh")`);
				setAttr ($checkerMesh+".visibility") (!`getAttr ($checkerMesh+".visibility")`); 
				break;
			case "none":
				for ($item in $list){
					string $nodeType = `nodeType $item`;
					if ($nodeType == "polyNormalPerVertex")
						setAttr ($item+".nodeState") 1;
					}
					
				// $vis = {1,0};
				break;
			case "normals":
				for ($item in $list){
					string $nodeType = `nodeType $item`;
					if ($nodeType == "polyNormalPerVertex")
						setAttr ($item+".nodeState") 0;
					}

				// if (`getAttr ($node+".partsEnable")` == 1){
					// warning "Baked Normals Disabled in Parts-Mode";
					// $vis = {1,0};
					// }
				// else
					// $vis = {0,1};
				break;
			}
/* 		string $attrs[] = {"peltingMesh","peltingSimulatedMesh"};
		if (size($vis)>0)
			for ($i=0;$i<size($attrs);$i++){
				$meshes = `listConnections ($node+"."+$attrs[$i])`;
				if ($meshes[0] != "")
					setAttr ($meshes[0]+".visibility") $vis[$i];
				}
				*/
		}
 }





//**************************************************************************
//ALL STUFF TO READ THE HELP FILE
//**************************************************************************

global proc pt_displayHelpText(string $filename)
{
string $s=pt_readFile($filename);
//string $match=pt_extractHelpText($s);
pt_helpWindow($s, $filename);
}


global proc string pt_readFile(string $filename)
{
string $where=`whatIs $filename`;
string $path=`match ":.*mel" $where`;
string $helpFile=`substring $path 3 (size($where))`;

string $s=pt_readFileByLine($helpFile);
return $s;
}

global proc string pt_readFileByLine(string $helpFile)
{
$fileId=`fopen $helpFile "r"`;
string $nextLine = `fgetline $fileId`;
string $s;
int $continue = 0;
while ( size( $nextLine ) > 0 ) {
	if (size(`match "<HELP>" $nextLine`)>0)
		$continue = !($continue);
	
	if ($continue == 1)
		$s=$s+$nextLine;	
	
	if (($continue == 0)&&(size($s)>0))
		break;		
	$nextLine = `fgetline $fileId`;
	
	}	
fclose $fileId; 
return $s;
} 

global proc string pt_extractHelpText(string $s)
{
string $matchText=`match "...*" $s`;

string $helpText[];

if (size(`match "<HELP>" $matchText`)>0){
	tokenize $matchText "<HELP>" $helpText;
	print (`match "<HELP>" $matchText`);
	}
else {
	$helpText[0]=$matchText;
	}

 
 return $helpText[1];
}

global proc pt_helpWindow(string $helpText,string $filename)
{
if (`window -ex pt_helpWindow`)
	deleteUI -wnd pt_helpWindow;
window -tlb 1 -t ($filename+" Help") pt_helpWindow;
formLayout pt_helpForm;
	scrollField -ww 1 -tx $helpText -ed 0 pt_helpScroll;
	setParent ..;
formLayout -e 
	-af pt_helpScroll "top" 0
	-af pt_helpScroll "bottom" 0
	-af pt_helpScroll "left" 0
	-af pt_helpScroll "right" 0
pt_helpForm;
showWindow pt_helpWindow;
window -e -w 860 pt_helpWindow;
}


//STUFF TO RESIZE WINDOW
global proc pt_resizeWindow()
{
	string $tab=pt_returnCurrentTab();
	string $frames[] = pt_returnFrameLayouts();
	int $h = 46 + 21 + 26;
	
	// if (`menuItem -q -cb pt_scriptMenuItem`)
		// $h+=`frameLayout -q -h ("pt_pelt_scriptFrame")`;
		// $h += 42;
	
	//	UV TOOLS tab
	//
	if ($tab == "uv")
		$frames ={"shell","tweak"};
	else
		$h += 21 + 21;
	for ($i=0;$i<size($frames);$i++)
		if (`frameLayout -q -m ("pt_pelt_"+$frames[$i]+"Frame")`){
				// if (`frameLayout -q -cl ("pt_"+$frames[$i]+"_springFrame")` == 0)
					// print (`frameLayout -q -h ("pt_pelt_"+$frames[$i]+"Frame")`);
				// if (`frameLayout -q -cl ("pt_"+$frames[$i]+"_springFrame")` == 0)
					// $h = $h + 22;

			$h = $h + (`frameLayout -q -h ("pt_pelt_"+$frames[$i]+"Frame")`) + 21;
			iconTextButton -e -i "pelt_downArrow.xpm" ("pt_pelt_"+$frames[$i]+"Button");
			}
		else{
			$h = $h + 21;
			iconTextButton -e -i "pelt_rightArrow.xpm" ("pt_pelt_"+$frames[$i]+"Button");
			}

	// if (`frameLayout -q -cl ("pt_simulation_springFrame")` == 0)
	// print (`frameLayout -q -h ("pt_simulation_springFrame")`);
	// print (`frameLayout -q -h ("pt_pelt_simulationFrame")`);	
			
	//	doesn't work on animation...how to get it to force ui...
	//
	// evalDeferred("window -e -h (`tabLayout -q -h pt_TabLayout`+46+21) peltingTools");
	
	window -e -h $h peltingTools;
}

global proc pt_setManageState(int $states[])
{
	int $i=0;
	for ($frame in pt_returnFrameLayouts()){
		frameLayout -e -m $states[$i] ("pt_pelt_"+$frame+"Frame");
		$i++;
		}
	
	pt_resizeWindow();
}


proc int pt_pluginQuery()
{
if (!(`pluginInfo -q -l closestPointOnCurve`)){
	//loadPlugin closestPointOnCurve;
	// warning "closestPointOnCurve plugin will be needed in future releases.";
	return 1;
	}
else if (!(`pluginInfo -q -l closestPointOnMesh`)){
	//loadPlugin closestPointOnCurve;
	warning "closestPointOnMesh plugin needed for optional brute force transferUV command!";
	return 1;
	}
return 1;
}


proc int pt_iconCheck()
{
	int $continue = 0;
	string $icons[] = {"pelt_default.xpm","pelt_icon.xpm","pelt_normals.xpm","pelt_downArrow.xpm","pelt_rightArrow.xpm"}; 
	string $env=`getenv xbmlangpath`;
	string $paths[];
	tokenize $env ";" $paths;
	$paths[size($paths)] = `internalVar -ubd`;
	for ($path in $paths){
		string $eIcons[]=`getFileList -folder ($path+"/")`;
		if (size(pt_returnIntersectedItems($icons, $eIcons)) == size($icons)){
			$continue = 1;
			break;
			}
		}
	return $continue;
	
}

proc int pt_scriptsCheck()
{
	int $continue = 0;
	string $scripts[] = {"Checker.png"}; 
	string $internal = `internalVar -usd`;
	string $env = `getenv "MAYA_SCRIPT_PATH"`;
	string $paths[];
	tokenize $env ";" $paths;
	
	$paths[size($paths)] = $internal;
	
	for ($path in $paths){
		string $eScripts[]=`getFileList -folder ($path+"/")`;
		if (size(pt_returnIntersectedItems($scripts, $eScripts)) == size($scripts)){
			$continue = 1;
			break;
			}
		}
	return $continue;
	
}


global proc peltingToolsSetup()
{
	int $continue = 1;
	if (pt_iconCheck() == 0){
		warning "Please put pelting icons into an icons directory!";
		$continue = 0;
		}
	if (pt_pluginQuery() == 0)
		$continue = 0;

	if (pt_scriptsCheck() == 0)
		warning "Please put Checker.png into a scripts directory";
	
	if ($continue == 1){
		global string $gShelfTopLevel;
	
		if (`tabLayout -exists $gShelfTopLevel`) {
			string $currentShelf = `tabLayout -query -selectTab $gShelfTopLevel`;
			setParent $currentShelf;
			string $buttonList[] = `shelfLayout -q -childArray $currentShelf`;
			for ($button in $buttonList)
				if (`shelfButton -q -annotation $button` == "Pelting Tools: by sunit parekh"){
					shelfLayout -e -pos $button (size($buttonList)) $currentShelf;
					print "Pelting Shelf Button already exists: Moving Pelting Button to end";
					$continue = 0;
					}
			
			if ($continue == 1){
				shelfButton 
					-command "source peltingTools.mel;peltingTools;"
					-label "Pelting Tools"
					-annotation "Pelting Tools: by sunit parekh"
					-image1 "pelt_icon.xpm"
					-style `shelfLayout -query -style $currentShelf`
					-width `shelfLayout -query -cellWidth $currentShelf`
					-height `shelfLayout -query -cellHeight $currentShelf`;
				print "Pelting Tools Successfully Setup";
				}
			}
		else
			warning "Shelf Tabs not visible.  Failed to make Pelting Button!";
		}
}


//DELETE OLD SCRIPT JOB
global proc pt_deleteScriptJob()
{
	string $jobs[] = `scriptJob -lj`;
	string $num;
	for ($i=0;$i<size($jobs);$i++){
		if (`gmatch ($jobs[$i]) ("*peltingTools")`){
			$num = `match "^[0-9]+" $jobs[$i]`;
			scriptJob -kill (int($num)) -force; 
			}
		}
}

//CREATE SCRIPT JOB
global proc pt_createScriptJob()
{
	pt_deleteScriptJob();
	scriptJob -p peltingTools -runOnce 1 -event "SceneOpened" "evalDeferred(\"peltingTools\")";
}


global proc pt_checkNode(string $name)
{
	//	adds attributes to existing pelt nodes: backward compatibility check
	//		
	string $node=pt_returnNodeFromName($name);
	string $cmd;
	if (!`objExists ($node+".peltingGroup")`)
		$cmd+="addAttr -ln peltingGroup -at message "+$node+";";
	if (!`objExists ($node+".peltingEdgeList")`)
		$cmd+="addAttr -ln peltingEdgeList -at message "+$node+";";
	if (!`objExists ($node+".peltingOriginal")`)
		$cmd+="addAttr -ln peltingOriginal -at message "+$node+";";
	if (!`objExists ($node+".peltingMesh")`)
		$cmd+="addAttr -ln peltingMesh -at message "+$node+";";
	if (!`objExists ($node+".peltingFrame")`)
		$cmd+="addAttr -ln peltingFrame -at message "+$node+";";
	if (!`objExists ($node+".peltingSpring")`)
		$cmd+="addAttr -ln peltingSpring -at message "+$node+";";
	if (!`objExists ($node+".peltingTextureMesh")`)
		$cmd+="addAttr -ln peltingTextureMesh -at message "+$node+";";
	if (!`objExists ($node+".peltingTextureFile")`)
		$cmd+="addAttr -ln peltingTextureFile -dt string "+$node+";";
	if (!`objExists ($node+".peltingSimulatedMesh")`)
		$cmd+="addAttr -ln peltingSimulatedMesh -at message "+$node+";";
	if (!`objExists ($node+".sVtxEnable")`)
		$cmd+="addAttr -ln sVtxEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".mVtxEnable")`)
		$cmd+="addAttr -ln mVtxEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".peltingStartVtx")`)
		$cmd+="addAttr -ln peltingStartVtx -at message  "+$node+";";
	if (!`objExists ($node+".peltingEndVtx")`)
		$cmd+="addAttr -ln peltingEndVtx -at message  "+$node+";";
	if (!`objExists ($node+".peltingShader")`)
		$cmd+="addAttr -ln peltingShader -at message  "+$node+";";
	if (!`objExists ($node+".peltingU")`)
		$cmd+="addAttr -ln peltingU -at double -min 0.001 "+$node+";";
	if (!`objExists ($node+".peltingV")`)
		$cmd+="addAttr -ln peltingV -at double -min 0.001 "+$node+";";
	if (!`objExists ($node+".peltingFrameSpring")`)
		$cmd+="addAttr -ln peltingFrameSpring -at message "+$node+";";
	if (!`objExists ($node+".peltingComponentList")`)
		$cmd+="addAttr -ln peltingComponentList -m -im 0 -at message "+$node+";";
	if (!`objExists ($node+".partsEnable")`)
		$cmd+="addAttr -ln partsEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".peltingType")`)
		$cmd+="addAttr -ln peltingType -dt \"string\" "+$node+";";
	if (!`objExists ($node+".edgeEnable")`)
		$cmd+="addAttr -ln edgeEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".peltEnable")`)
		$cmd+="addAttr -ln peltEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".simulationEnable")`)
		$cmd+="addAttr -ln simulationEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".visualisationEnable")`)
		$cmd+="addAttr -ln visualisationEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".partsReuse")`)
		$cmd+="addAttr -ln partsReuse -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".partsRegion")`)
		$cmd+="addAttr -ln partsRegion -at long -min 0 "+$node+";";
	if (!`objExists ($node+".extraEnable")`)
		$cmd+="addAttr -ln extraEnable -at long -min 0 -max 1 "+$node+";";
	if (!`objExists ($node+".extraStrength")`)
		$cmd+="addAttr -ln extraStrength -at double "+$node+";";

	if ($cmd != "")
		pt_setLockedNode($cmd,$node);
	
	
	string $edgeList = pt_returnFirstItemInList(`listConnections ($node+".peltingEdgeList")`);
	if ($edgeList != ""){
		string $edgesVtxs[] = `sets -q $edgeList`;
		string $name = `getAttr ($node+".peltingGroupName")`;
		if (size($edgesVtxs) > 0){
			if (`match "vtx" (""+$edgesVtxs[0]+"")` == ""){
				warning "I'm deleting your old Edge List, please enter new one!";
				pt_setLockedNode("delete "+$edgeList,$edgeList);
				pt_createEdgeSelectionSet($name+"_EdgeList",$node);
				setAttr ($node+".continuity") 0;
				// warning "Please Re-enter Edge List!";
				}
			}
		}
}


//ABOUT WINDOW
global proc pt_aboutWindow()
{
	if (`window -ex pt_aboutWindow`)
		deleteUI -wnd pt_aboutWindow;

	window -t "About" -tlb 1 -s 0 pt_aboutWindow;
	formLayout pt_aboutForm;
		scrollField -ww 1 -tx "peltingTools.mel\nversion 1.0\nDecember 5th 2005\n\nby sunit parekh\nhttp://www.sunitparekh.com\ninfo@sunitparekh.com" -ed 0 pt_aboutScroll;
		setParent ..;
	formLayout -e 
		-af pt_aboutScroll "top" 0
		-af pt_aboutScroll "bottom" 0
		-af pt_aboutScroll "left" 0
		-af pt_aboutScroll "right" 0
	pt_aboutForm;
	showWindow pt_aboutWindow;
	window -e -w 205 -h 156 pt_aboutWindow;
}


//SCRIPT  WINDOW
global proc pt_scriptCmdsWindow()
{
	if (pt_returnMayaVersion() == "6.0")
		$iconTextButton = "iconTextButton";
	else
		$iconTextButton = "iconTextButton -fn \"smallFixedWidthFont\"";

	string $name = "script";
	if (`window -ex pt_scriptCmdsWindow`)
		deleteUI -wnd pt_scriptCmdsWindow;
	
	window -t "Script Commands" pt_scriptCmdsWindow;
	frameLayout -lv 0 -cl 0 -bv 1 -bs "in" -cll 1 -m 1 ("pt_pelt_"+$name+"Frame");
		formLayout ("pt_pelt_"+$name+"Form");
			textField -ann "Click on CMDS to get list of acceptable cmds" ("pt_pelt_"+$name+"Field");
			eval($iconTextButton+" -h 21 -bgc .67 .72 .75 -ann \"Select to get list of commands\" -st \"textOnly\" -l \"cmds>\"  -c (\"\") "+("pt_"+$name+"_cmdsButton")+"");
			popupMenu -b 1;
				menuItem -l "Insert from Below";
				menuItem -d 1;
				// menuItem -l "*bypass";
				// menuItem -l "*requires (0=no pelt group, 1=pelt group)";
				menuItem -l "*rewind" -c ("pt_appendToCmd(\"rewind\")");
				menuItem -l "*play" -c ("pt_appendToCmd(\"play\")");;
				menuItem -l "*stop" -c ("pt_appendToCmd(\"stop\")");;
				menuItem -ann "cuts selected edges" -l "*cut (requires edge selection)" -c ("pt_appendToCmd(\"cut\")");;
				menuItem -ann "merges selected edges" -l "*merge (requires edge selection)" -c ("pt_appendToCmd(\"merge\")");;
				menuItem -l "*continuous" -c ("pt_appendToCmd(\"continuous\")");;
				menuItem -l "*frame (xy, xz, yz)" -c ("pt_appendToCmd(\"frame\")");;
				menuItem -l "*pelt (world, even)" -c ("pt_appendToCmd(\"pelt\")");;
				menuItem -l "*deletePelt" -c ("pt_appendToCmd(\"deletePelt\")");;
				menuItem -l "*removePelt" -c ("pt_appendToCmd(\"removePelt\")");;
				menuItem -d 1;
				menuItem -l "Examples" -sm 1;
					menuItem -l "Cut and Re-Pelt (with rewind)" -c ("textField -e -tx (\"rewind;cut;continuous;deletePelt;pelt world;play;\") (\"pt_pelt_"+$name+"Field\");textField -e -tx (\"pt_runScriptedCmd(\\\"rewind;cut;continuous;deletePelt;pelt world;play;\\\")\") (\"pt_pelt_"+$name+"outputField\")");
					menuItem -l "Cut and Re-Pelt (from current frame)" -c ("textField -e -tx (\"cut;continuous;deletePelt;pelt world;play;\") (\"pt_pelt_"+$name+"Field\");textField -e -tx (\"pt_runScriptedCmd(\\\"cut;continuous;deletePelt;pelt world;play;\\\")\") (\"pt_pelt_"+$name+"outputField\")");
					menuItem -d 1;
					menuItem -l "Merge and Re-Pelt (with rewind)" -c ("textField -e -tx (\"rewind;merge;continuous;deletePelt;pelt world;play;\") (\"pt_pelt_"+$name+"Field\");textField -e -tx (\"pt_runScriptedCmd(\\\"rewind;merge;continuous;deletePelt;pelt world;play;\\\")\") (\"pt_pelt_"+$name+"outputField\")");
					menuItem -l "Merge and Re-Pelt (from current frame)" -c ("textField -e -tx (\"merge;continuous;deletePelt;pelt world;play;\") (\"pt_pelt_"+$name+"Field\");textField -e -tx (\"pt_runScriptedCmd(\\\"merge;continuous;deletePelt;pelt world;play;\\\")\") (\"pt_pelt_"+$name+"outputField\")");
					menuItem -d 1;
					menuItem -l "Command line Pelt (select edges to cut first)" -c ("textField -e -tx (\"rewind;cut;continuous;frame xz;pelt world;play;\") (\"pt_pelt_"+$name+"Field\");textField -e -tx (\"pt_runScriptedCmd(\\\"rewind;cut;continuous;frame xz;pelt world;play;\\\")\") (\"pt_pelt_"+$name+"outputField\")");
					
			separator ("pt_"+$name+"_separator1");
			eval($iconTextButton+" -h 19 -bgc .57 .62 .65 -ann \"Executes above commands\" -st \"textOnly\" -l \"EXECUTE CMD\"  -c (\"eval(pt_generateScriptedCmd(`textField -q -tx "+("pt_pelt_"+$name+"Field")+"`,\\\"cmd\\\"))\") "+("pt_"+$name+"_executeButton")+"");
			eval($iconTextButton+" -h 19 -bgc .47 .52 .55 -ann \"Generates script from above commands\" -st \"textOnly\" -l \"GENERATE CMD\"  -c (\"pt_generateScriptedCmd(`textField -q -tx "+("pt_pelt_"+$name+"Field")+"`,\\\"script\\\")\") "+("pt_"+$name+"_generateButton")+"");
			eval($iconTextButton+" -h 19 -bgc .37 .42 .45 -ann \"Clears textField\" -st \"textOnly\" -l \"Clear All\"  -c (\"textField -e -tx (\\\"\\\") "+("pt_pelt_"+$name+"Field")+";textField -e -tx (\\\"\\\") "+("pt_pelt_"+$name+"outputField")+"\") "+("pt_"+$name+"_clearButton")+"");
			print ($iconTextButton+" -h 19 -bgc .37 .42 .45 -ann \"Clears textField\" -st \"textOnly\" -l \"Clear All\"  -c (\"textField -e -tx "+("\"\"")+" "+("pt_pelt_"+$name+"Field")+"\") "+("pt_"+$name+"_clearButton")+"");
			textField -ed 0 -ann "Prints Output of GENERATE CMD" ("pt_pelt_"+$name+"outputField");
			// iconTextButton;
		setParent ..;
	setParent ..;
	formLayout -e 
		-af ("pt_pelt_"+$name+"Field") "left" 0
		-af ("pt_pelt_"+$name+"Field") "right" 42
		
		-ac ("pt_"+$name+"_cmdsButton") "left" 0 ("pt_pelt_"+$name+"Field")
		-af ("pt_"+$name+"_cmdsButton") "right" 0
		
		-ac ("pt_"+$name+"_separator1") "top" -1 ("pt_"+$name+"_cmdsButton")
		-af ("pt_"+$name+"_separator1") "left" 0
		-af ("pt_"+$name+"_separator1") "right" 0
		
		-ap ("pt_"+$name+"_executeButton") "right" 0 33
		-af ("pt_"+$name+"_executeButton") "left" 0
		-ac ("pt_"+$name+"_executeButton") "top" -1 ("pt_"+$name+"_separator1")
		
		-ac ("pt_"+$name+"_generateButton") "top" -1 ("pt_"+$name+"_separator1")
		-ac ("pt_"+$name+"_generateButton") "left" 0 ("pt_"+$name+"_executeButton")
		-ac ("pt_"+$name+"_generateButton") "right" 0 ("pt_"+$name+"_clearButton")
		
		-af ("pt_"+$name+"_clearButton") "right" 0
		-ap ("pt_"+$name+"_clearButton") "left" 0 66
		-ac ("pt_"+$name+"_clearButton") "top" -1 ("pt_"+$name+"_separator1")
		
		-ac ("pt_pelt_"+$name+"outputField") "top" 0 ("pt_"+$name+"_generateButton")
		-af ("pt_pelt_"+$name+"outputField") "left" 0
		-af ("pt_pelt_"+$name+"outputField") "right" 0
		
	("pt_pelt_"+$name+"Form");
	showWindow pt_scriptCmdsWindow;
	window -e -h (31+66) -w 450 pt_scriptCmdsWindow;	
}


//**************************************************************************
//MAIN UI STUFF
//**************************************************************************

global proc pt_pelt_createFrameLayout(string $parent,string $name, string $label, int $manage)
{
	setParent $parent;
	string $iconTextButton;
	string $iconTextCheckBox;
	if (pt_returnMayaVersion() == "6.0")
		$iconTextButton = "iconTextButton";
	else
		$iconTextButton = "iconTextButton -fn \"smallFixedWidthFont\"";
	
	string $mSepStyle="single";


	if ($name != "cutting"){
		// eval (pt_returnButtonCmd(("pt_pelt_"+$name+"Button"), ("frameLayout -e -m (!`frameLayout -q -m "+("pt_pelt_"+$name+"Frame")+"`) "+("pt_pelt_"+$name+"Frame")+";pt_resizeWindow"), "smallFixedWidthFont", "pelt_rightArrow.xpm", "iconAndTextHorizontal",$label,$label,".43 .43 .48","19"));
		eval($iconTextButton+" -bgc .43 .43 .48 -h 19 -l \""+$label+"\" -ann \""+$label+"\" -i \"pelt_rightArrow.xpm\" -style \"iconAndTextHorizontal\" -c (\"frameLayout -e -m (!`frameLayout -q -m "+("pt_pelt_"+$name+"Frame")+"`) "+("pt_pelt_"+$name+"Frame")+";pt_resizeWindow\") (\"pt_pelt_"+$name+"Button\")");
		}
	if (pt_returnMayaVersion() == "6.0"){
		$iconTextButton = "iconTextButton";
		$iconTextCheckBox = "iconTextCheckBox";
		}
	else{
		$iconTextButton = "iconTextButton -fn \"smallFixedWidthFont\"";
		$iconTextCheckBox = "iconTextCheckBox -fn \"smallFixedWidthFont\"";
		}

	
	separator -h 1 -style $mSepStyle ("pt_pelt_"+$name+"Separator1");
	frameLayout -lv 0 -bv 0 -m $manage("pt_pelt_"+$name+"Frame");
		formLayout ("pt_pelt_"+$name+"Form");
			separator -h 1 -style $mSepStyle ("pt_pelt_"+$name+"Separator2");
			switch ($name){
				case "groups":
					string $sStyle = "single";
					iconTextButton -e -bgc .33 .33 .38 ("pt_pelt_"+$name+"Button");
					textScrollList -nr 4 -ams 0 -sc ("pt_selectPeltGroup(pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`))") ("pt_pelt_groupList");
					
					// popupMenu -b 3 -p ("pt_pelt_groupList") pt_peltGroupListMenu;	
						// menuItem -l "Toggle Visibility..." -c ("pt_toggleVis(`textScrollList -q -si pt_pelt_groupList`)");
						

					text -h 22 -l "Pelt Name" -al "center" ("pt_pelt_nameText");
					textField -fn "boldLabelFont" -h 22 -ann "Enter Name For Pelt Here and Press: ENTER to create" -cc ("pt_createPeltGroup(`textField -q -tx pt_pelt_nameField`,0)") ("pt_pelt_nameField");
					
					eval ($iconTextButton+" -h 19 -l \"add\" -bgc .67 .72 .75  -style textOnly -ann \"Adds Pelting Group\" -c (\"pt_createPeltGroup(`textField -q -tx pt_pelt_nameField`,0)\") (\"pt_"+$name+"_addButton\")");
					eval ($iconTextButton+" -h 19 -l \"rem\" -bgc .57 .62 .65 -style \"textOnly\" -ann \"Removes Pelting Group\" -c (\"pt_deletePeltGroup(`textScrollList -q -si pt_pelt_groupList`)\") (\"pt_"+$name+"_remButton\")");
					separator -style $sStyle ("pt_pelt_"+$name+"_separator1");
					separator -style $sStyle ("pt_pelt_"+$name+"_separator2");
					separator -hr 0 -style $sStyle ("pt_pelt_"+$name+"_separator3");
					// eval ($iconTextButton+" -h 19 -l \"shell\" -bgc .67 .72 .75  -style textOnly -ann \"Face Shell Select\" -c (\"pt_shellSelectMode()\") (\"pt_"+$name+"_shellButton\")");
					eval ($iconTextCheckBox+" -h 19 -l \"parts\" -bgc .57 .62 .65  -style textOnly -ann \"Toggle Parts-Element Mode\" -onc (\"pt_togglePartsElement(`textScrollList -q -si pt_pelt_groupList`, 1);iconTextCheckBox -e -bgc .37 .52 .65 (\\\"pt_"+$name+"_partsButton\\\");\") -ofc (\"pt_togglePartsElement(`textScrollList -q -si pt_pelt_groupList`, 0);iconTextCheckBox -e -bgc .57 .62 .65 (\\\"pt_"+$name+"_partsButton\\\")\") (\"pt_"+$name+"_partsButton\")");
					eval ($iconTextCheckBox+" -h 19 -l \"vis\" -bgc .47 .52 .55  -style textOnly -ann \"Toggle Parts-Element Mode\" -onc (\"pt_toggleVis(pt_returnCurrentPeltNode(),0);\") -ofc (\"pt_toggleVis(pt_returnCurrentPeltNode(),1);\") (\"pt_"+$name+"_visButton\")");
					
					formLayout -e
						-af ("pt_pelt_groupList") "top" 0
						-af ("pt_pelt_groupList") "bottom" 24
						-af ("pt_pelt_groupList") "right" 35
						-af ("pt_pelt_groupList") "left" 0
					
						-af ("pt_"+$name+"_addButton") "top" -1
						-af ("pt_"+$name+"_addButton") "right" 0
						-ac ("pt_"+$name+"_addButton") "left" 0 ("pt_pelt_groupList")
						
						-ac ("pt_"+$name+"_remButton") "top" 0 ("pt_"+$name+"_addButton")
						-af ("pt_"+$name+"_remButton") "right" 0
						-ac ("pt_"+$name+"_remButton") "left" 0 ("pt_pelt_groupList")

						-ac ("pt_pelt_"+$name+"_separator1") "top" -1 ("pt_"+$name+"_remButton") 
						-ac ("pt_pelt_"+$name+"_separator1") "left" 0 ("pt_pelt_groupList")
						-af ("pt_pelt_"+$name+"_separator1") "right" 0
 						
						-ac ("pt_"+$name+"_partsButton") "top" -1 ("pt_pelt_"+$name+"_separator1") 
						-ac ("pt_"+$name+"_partsButton") "left" 0 ("pt_pelt_groupList")
						-af ("pt_"+$name+"_partsButton") "right" 0
						-ac ("pt_"+$name+"_partsButton") "bottom" -1 ("pt_pelt_"+$name+"_separator2")

						-af ("pt_pelt_"+$name+"_separator2") "bottom" 23  
						-ac ("pt_pelt_"+$name+"_separator2") "left" 0 ("pt_pelt_groupList")
						-af ("pt_pelt_"+$name+"_separator2") "right" 0

						
						-af ("pt_"+$name+"_visButton") "bottom" 1
						-af ("pt_"+$name+"_visButton") "right" 0
						-ac ("pt_"+$name+"_visButton") "left" 0 ("pt_pelt_groupList")
						-ac ("pt_"+$name+"_visButton") "top" -1 ("pt_pelt_"+$name+"_separator2")
						
						-ac ("pt_pelt_"+$name+"_separator3") "right" -1 ("pt_"+$name+"_visButton")
						-af ("pt_pelt_"+$name+"_separator3") "bottom" 1
						-ac ("pt_pelt_"+$name+"_separator3") "top" 0 ("pt_pelt_groupList")
						
						-af ("pt_pelt_nameText") "bottom" 1
						-ac ("pt_pelt_nameText") "right" 3 ("pt_pelt_"+$name+"_separator3")
						
						-af ("pt_pelt_nameField") "bottom" 1
						-af ("pt_pelt_nameField") "left" 0
						-ac ("pt_pelt_nameField") "right" 0 ("pt_pelt_nameText")
					
					("pt_pelt_"+$name+"Form");
					break;
				case "cutting":
				
					$iconTextButton = "iconTextButton";
					string $sStyle = "single";
					string $iconTextButton;
					eval($iconTextButton+" -h 19 -bgc .85 .85 .95 -st \"textOnly\" -ann \"Cuts Selected Edges\" -l \"Cut\"  -c (\"pt_cutEdges(\\\"pelt\\\");\") (\"pt_"+$name+"_CutButton\")");
					eval($iconTextButton+" -h 19 -bgc .75 .75 .85  -st \"textOnly\" -ann \"Merges Border Edges in Selection\" -l \"Merge\"  -c (\"pt_mergeEdges()\") (\"pt_"+$name+"_MergeButton\")");
					eval($iconTextButton+" -h 19 -bgc .65 .65 .75  -st \"textOnly\" -ann \"Selects Edge Loop - Thanks to OMToolBox\" -l \"Loop\"  -c (\"pt_selectLoop()\") (\"pt_"+$name+"_LoopButton\")");
					formLayout -e 
						-af ("pt_"+$name+"_CutButton") "left" 0
						-ap ("pt_"+$name+"_CutButton") "right" 0 33
						-ac ("pt_"+$name+"_MergeButton") "right" 0 ("pt_"+$name+"_LoopButton")
						-ac ("pt_"+$name+"_MergeButton") "left" 0 ("pt_"+$name+"_CutButton")
						
						-af ("pt_"+$name+"_LoopButton") "right" 0
						-ap ("pt_"+$name+"_LoopButton") "left" 0 66
					("pt_pelt_"+$name+"Form");
					break;
				//	MULTI ELEMENT CONTROLS
				//
				case "parts":
					string $sStyle = "single";
					

					textScrollList -nr 1 -ams 0 -sc ("pt_selectComponentList(pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_elementList`));textScrollList -e -da pt_pelt_elementList;") ("pt_pelt_elementList");											

					eval ($iconTextButton+" -h 19 -l \"Select Shell\" -bgc .57 .62 .65  -style textOnly -ann \"Converts Selection to Vertex Shell\" -c (\"pt_shellSelectMode()\") (\"pt_"+$name+"_shellButton\")");					
					eval ($iconTextButton+" -h 19 -l \"Replace List\" -bgc .67 .72 .75  -style textOnly -ann \"Replace Components in List (Need to be Vertices)\" -c (\"pt_storeComponentList(`textScrollList -q -ai pt_pelt_elementList`,`ls -sl`)\") (\"pt_"+$name+"_addButton\")");
					
					formLayout -e
						-ac ("pt_pelt_elementList") "top" 0 ("pt_"+$name+"_shellButton")
						-af ("pt_pelt_elementList") "right" 0
						-af ("pt_pelt_elementList") "left" 0
						-af ("pt_pelt_elementList") "bottom" 1
					
						-af ("pt_"+$name+"_addButton") "top" 0
						-af ("pt_"+$name+"_addButton") "right" 0
						-ap ("pt_"+$name+"_addButton") "left" 0 50
						
						-af ("pt_"+$name+"_shellButton") "top" 0 
						-ap ("pt_"+$name+"_shellButton") "right" 0 50
						-af ("pt_"+$name+"_shellButton") "left" 0
					
					("pt_pelt_"+$name+"Form");
				
				
					break;
				
				//	EDGE CONTROLS
				//
				case "edge":
					string $sStyle = "single";
					eval($iconTextButton+" -h 19 -bgc .57 .62 .65  -st \"textOnly\" -ann \"Walks along Border Edges (Select one border edge first)\" -l \"Add Continuous Edges\"  -c (\"pt_continuousEdgeList(`textScrollList -q -ai pt_edgeList`,`ls -sl`,0)\") pt_continuousButton");
					
					textScrollList -nr 1 -h 19 -ann "Click to Select List" -sc ("pt_selectEdgeList(`textScrollList -q -si pt_edgeList`);textScrollList -e -da pt_edgeList;") pt_edgeList;
 				
					formLayout -e
						-af pt_continuousButton "top" 0
						-af pt_continuousButton "right" 0
						-af pt_continuousButton "left" 0
						
						
						-af pt_edgeList "right" 0
						-af pt_edgeList "left" 0
						-ac pt_edgeList "top" 0 pt_continuousButton
						-af pt_edgeList "bottom" 1

					("pt_pelt_"+$name+"Form");
					break;

				//	PELT CONTROLS
				//
				case "pelt":
					eval("checkBox -w 15 -h 19 -bgc .67 .72 .75 -l \"\" -ann \"Enable to Use Symmetry Axis\" -cc (\"pt_populateVtxs(pt_returnCurrentPeltNode())\") pt_enSVtxBox");
					eval("checkBox -w 15 -h 19 -bgc .67 .72 .75 -l \"\" -ann \"Enable to Use Symmetry Axis\" -cc (\"pt_populateVtxs(pt_returnCurrentPeltNode())\") pt_enMVtxBox");
					// eval($iconTextCheckBox+" -w 23 -h 19 -bgc .67 .72 .75  -st \"textOnly\" -l \"en\" -cc (\"pt_populateVtxs(stringArrayToString(`textScrollList -q -si pt_pelt_groupList`,\\\"\\\"))\") pt_enSVtxBox");
					eval($iconTextButton+" -h 19 -bgc .67 .72 .75 -w 35 -ann \"Add Start Vertex for Symmetry\" -st \"textOnly\" -l \"start\" -c (\"pt_setVertexList(`filterExpand -sm 31`,pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`),\\\"pt_sVtxList\\\",\\\"StartVtx\\\")\") pt_sVtxButton");
					eval($iconTextButton+" -h 19 -bgc .67 .72 .75 -w 35 -ann \" Add Mid Vertex for Symmetry\" -st \"textOnly\" -l \"mid\" -c (\"pt_setVertexList(`filterExpand -sm 31`,pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`),\\\"pt_eVtxList\\\",\\\"EndVtx\\\")\") pt_eVtxButton");
					textScrollList -h 19 -nr 1 -ann "Click to Select Vtx" -sc ("pt_selectVtxs(`textScrollList -q -si pt_pelt_groupList`,\"peltingStartVtx\");textScrollList -e -da pt_sVtxList;") pt_sVtxList;
					textScrollList -h 19 -nr 1 -ann "Click to Select Vtx" -sc ("pt_selectVtxs(`textScrollList -q -si pt_pelt_groupList`,\"peltingEndVtx\");textScrollList -e -da pt_eVtxList;") pt_eVtxList;
					
					eval($iconTextButton+" -ann \"Creates Pelting Frame\" -h 19 -bgc .57 .62 .65  -st \"textOnly\" -l \"Create Pelting Frame\"  -c (\"pt_createPeltingFrame(pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`),\\\"\\\",0)\") pt_frameButton");
					textScrollList -h 18 -nr 1 -ann "Click to select Frame - Right Click for options" -sc ("select (`textScrollList -q -si pt_frameList`);textScrollList -e -da pt_frameList;") -dkc ("delete (`textScrollList -q -si pt_frameList`);pt_getStoredFrames(`ls -type nurbsCurve`);") pt_frameList;

					popupMenu -b 3 -p pt_frameList pt_frameListMenu;
							menuItem -l "Flip along X-Axis..." -c ("setAttr  (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scaleX\") (-1*(`getAttr (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scaleX\")`))") pt_flipXItem;
							menuItem -l "Flip along Y-Axis..." -c ("setAttr  (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scaleY\") (-1*(`getAttr (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scaleY\")`))") pt_flipYItem;
							menuItem -l "Flip along Z-Axis..." -c ("setAttr  (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scaleZ\") (-1*(`getAttr (pt_returnFirstItemInList(eval(\"textScrollList -q -ai pt_frameList\"))+\".scaleZ\")`))") pt_flipZItem;
							// menuItem -d 1;
							// menuItem -l "Rotate 90 X-Axis..." -c ("setAttr  (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scaleX\") (-1*(`getAttr (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scaleX\")`))") pt_rotateHItem;
							// menuItem -l "Rotate 90 Y-Axis..." -c ("setAttr  (	(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scaleY\") (-1*(`getAttr (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scaleY\")`))") pt_rotateHItem;
							// menuItem -l "Rotate 90 Z-Axis..." -c ("setAttr  (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scaleZ\") (-1*(`getAttr (stringArrayToString(eval(\"textScrollList -q -ai pt_frameList\"),\"\")+\".scaleZ\")`))") pt_rotateVItem;
							menuItem -d 1;
							menuItem -l "Delete Frame..." -bld 0 -c ("pt_deleteFrame(`textScrollList -q -ai pt_frameList`)");

					iconTextRadioCollection;
						iconTextRadioButton -w 22 -h 19 -bgc .75 .85 .89  -st "textOnly" -l "xy" -onc ("pt_setFrameAxis(`textScrollList -q -ai pt_frameList`, \"z\")") pt_xy_frameButton;
						iconTextRadioButton -sl -w 22 -h 19 -bgc .65 .75 .79  -st "textOnly" -l "xz" -onc ("pt_setFrameAxis(`textScrollList -q -ai pt_frameList`, \"y\")") pt_xz_frameButton;
						iconTextRadioButton -w 22 -h 19 -bgc .55 .65 .69  -st "textOnly" -l "yz" -onc ("pt_setFrameAxis(`textScrollList -q -ai pt_frameList`, \"x\")") pt_yz_frameButton;
					
					
					
					string $sStyle = "in";
					separator -style $sStyle ("pt_pelt_"+$name+"_separator1");
					floatFieldGrp -h 18 -nf 1 -adj 1 -cw 2 45 -cat 1 "both" 0 -cal 1 "both" -l "Frame Strength" -value1 1.00 -pre 3 pt_frameField;
					separator -style $sStyle ("pt_pelt_"+$name+"_separator2");
					floatFieldGrp -h 18 -nf 1 -adj 1 -cw 2 45 -cat 1 "both" 0 -cal 1 "both" -l "Mesh Strength" -value1 1.00 -pre 3 pt_meshField;
					separator -style $sStyle ("pt_pelt_"+$name+"_separator3");
					intFieldGrp -h 18 -nf 1 -adj 1 -cw 2 45 -cat 1 "both" 0 -cal 1 "both" -l "Walk Length" -value1 1 pt_lengthField;
					
					//	PELT button
					//
					separator -style $sStyle ("pt_pelt_"+$name+"_separator4");
					eval($iconTextButton+" -h 19 -bgc .67 .72 .75  -st \"textOnly\" -l \"PELT (world)\" -ann \"Pelt mesh - Right Click for more options\"  -c (\"pt_peltMesh(0,\\\"\\\")\") pt_PeltButton");
					popupMenu -b 3 -p pt_PeltButton;	
						radioMenuItemCollection;
							menuItem -l "Use World Distances (Head-Type)" -rb 1 -c ("iconTextButton -e -l \"PELT (world)\" pt_PeltButton") pt_pelt_distanceItem;
							menuItem -l "Use Even Distances (Body-Type)" -rb 0 -c ("iconTextButton -e -l \"PELT (even)\" pt_PeltButton") pt_pelt_evenItem;
				
					formLayout -e
						-af pt_enSVtxBox "top" 0
						-af pt_enSVtxBox "left" 0
						
						-af pt_sVtxButton "top" 0
						-ac pt_sVtxButton "left" 0 pt_enSVtxBox

						-af pt_sVtxList "top" 0
						-ac pt_sVtxList "left" 0 pt_sVtxButton
						-ap pt_sVtxList "right" 0 50 
						
						-af pt_enMVtxBox "top" 0
						-af pt_enMVtxBox "right" 0						
						
						-af pt_eVtxButton "top" 0
						-ac pt_eVtxButton "right" 0 pt_enMVtxBox
						
						-af pt_eVtxList "top" 0
						-ap pt_eVtxList "left" 0 50 
						-ac pt_eVtxList "right" 0 pt_eVtxButton
						
						-ac pt_frameButton "top" 0 pt_eVtxList
						-af pt_frameButton "right" 0
						-af pt_frameButton "left" 0
						
						-af pt_frameList "left" 0
						-ac pt_frameList "top" 0 pt_frameButton
						-af pt_frameList "right" 66
						
						-ac pt_xy_frameButton "left" 0 pt_frameList 
						-ac pt_xy_frameButton "top" 0 pt_frameButton 
						
						-ac pt_xz_frameButton "top" 0 pt_frameButton
						-ac pt_xz_frameButton "left" 0 pt_xy_frameButton
						-ac pt_xz_frameButton "right" 0 pt_yz_frameButton
						
						-ac pt_yz_frameButton "top" 0 pt_frameButton
						-af pt_yz_frameButton "right" 0 

						-ac ("pt_pelt_"+$name+"_separator1") "top" -1 pt_yz_frameButton
						-af ("pt_pelt_"+$name+"_separator1") "right" 0
						-af ("pt_pelt_"+$name+"_separator1") "left" 0
						
						-ac pt_frameField "top" -1 ("pt_pelt_"+$name+"_separator1")
						-af pt_frameField "left" 0
						-af pt_frameField "right" 0
						
						-ac ("pt_pelt_"+$name+"_separator2") "top" 0 pt_frameField
						-af ("pt_pelt_"+$name+"_separator2") "right" 0
						-af ("pt_pelt_"+$name+"_separator2") "left" 0
						
						-ac pt_meshField "top" -1 ("pt_pelt_"+$name+"_separator2")
						-af pt_meshField "left" 0
						-af pt_meshField "right" 0
						
						-ac ("pt_pelt_"+$name+"_separator3") "top" 0 pt_meshField
						-af ("pt_pelt_"+$name+"_separator3") "right" 0
						-af ("pt_pelt_"+$name+"_separator3") "left" 0
						
						-ac pt_lengthField "top" -1 ("pt_pelt_"+$name+"_separator3")
						-af pt_lengthField "left" 0
						-af pt_lengthField "right" 0
						
						-ac ("pt_pelt_"+$name+"_separator4") "top" 0 pt_lengthField
						-af ("pt_pelt_"+$name+"_separator4") "right" 0
						-af ("pt_pelt_"+$name+"_separator4") "left" 0
						
						-ac pt_PeltButton "top" -1 ("pt_pelt_"+$name+"_separator4") 
						-af pt_PeltButton "bottom" 1
						-af pt_PeltButton "left" 0
						-af pt_PeltButton "right" 0
						
					("pt_pelt_"+$name+"Form");
					break;

				//	SIMULATION CONTROLS
				//
				case "simulation":
					string $sStyle = "in";
					string $mStyle = "single";
					textScrollList -nr 1 -h 19 -ann "Right Click for more options" -sc ("pt_selectPeltGrp(`textScrollList -q -ai pt_peltList`,pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`),\""+$name+"\");textScrollList -e -da pt_peltList;") pt_peltList;
					popupMenu -b 3 -p pt_peltList pt_peltListMenu;
						menuItem -l "Select Mesh..." -c ("pt_selectPeltParts(\"peltingMesh\", pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`))");
						menuItem -l "Select Frame..." -c ("pt_selectPeltParts(\"peltingFrame\",  pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`))");
						menuItem -l "Select Springs..." -c ("pt_selectPeltParts(\"peltingSpring\",  pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`))");		
						menuItem -d 1;
						menuItem -l "Delete Pelt..." -c ("pt_deletePelt(pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`));currentTime -e (`playbackOptions -q -ast`);");
						menuItem -d 1;
						menuItem -l "Remove Pelt From Simulation..." -bld 1 -c ("pt_removeSimPelt(pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`),0);currentTime -e (`playbackOptions -q -ast`);");
						
					
					eval($iconTextButton+" -h 19 -bgc .57 .62 .65 -ann \"Paint per-vertex mesh weights\"  -st \"textOnly\" -l \"Paint Local Mesh Weights\" -c (\"warning \\\"Not yet implemented\\\"\") (\"pt_"+$name+"_paintButton\")");
					separator -style $mStyle ("pt_pelt_"+$name+"_separator6");
					eval($iconTextCheckBox+" -h 19 -bgc .67 .72 .75 -ann \"Add per-vertex Springs\"  -st \"textOnly\" -l \"Add Local Per-Vertex Springs\" -onc (\"pt_toggleAddSpringFrame(`textScrollList -q -si pt_pelt_groupList`);window -e -h ((`window -q -h peltingTools`)+21) peltingTools;\") -cc (\"pt_toggleAddSpringFrame(`textScrollList -q -si pt_pelt_groupList`);window -e -h ((`window -q -h peltingTools`)-21) peltingTools;\") (\"pt_"+$name+"_addSpringBox\")");
					frameLayout -cll 1 -cl 1 -bs "in" -lv 0 -bv 0 ("pt_"+$name+"_springFrame");
						formLayout ("pt_"+$name+"_springForm");
							intFieldGrp -h 18 -nf 1 -adj 1 -cw 2 22 -cat 1 "both" 0 -cal 1 "both" -l "Walk Length:" -value1 1 pt_addLengthField;
							eval($iconTextButton+" -h 19 -bgc .57 .62 .65 -ann \"Select Vertices and then Add Springs\"  -st \"textOnly\" -l \"Add Springs\" -c (\"pt_addPerVertexSprings(`textScrollList -q -si pt_pelt_groupList`)\") (\"pt_"+$name+"_addSpringButton\")");
							separator -hr 0 -style $mStyle("pt_pelt_"+$name+"_springSeparator1");
							formLayout -e 
								-af pt_addLengthField "left" 0
								-ac pt_addLengthField "right" -1 ("pt_pelt_"+$name+"_springSeparator1")
								
								-af ("pt_"+$name+"_addSpringButton") "right" 0
								-ac ("pt_"+$name+"_addSpringButton") "left" -1 ("pt_pelt_"+$name+"_springSeparator1")
								
								-af ("pt_pelt_"+$name+"_springSeparator1") "top" 0
								-af ("pt_pelt_"+$name+"_springSeparator1") "bottom" 0
								-ap ("pt_pelt_"+$name+"_springSeparator1") "right" 0 50
							("pt_"+$name+"_springForm");
							setParent ..;
						setParent ..;
					// iconTextButton -h 19 -bgc .67 .72 .75 -ann "Re-calculate frame strength"  -st "textOnly" -l "Re-frame Strength" -c ("pt_reSpringStrength(`textScrollList -q -si pt_pelt_groupList`, `textScrollList -q -ai pt_peltList`, `floatField -q -v "pt_pelt_reFrameSpringField"`, \"Frame\")") ("pt_pelt_reFrameSpringButton")
					// eval($iconTextButton+" -h 19 -bgc .67 .72 .75 -ann \"Re-calculate frame strength\"  -st \"textOnly\" -l \"Re-frame Strength\" -c (\"pt_reSpringStrength(`textScrollList -q -si pt_pelt_groupList`, `textScrollList -q -ai pt_peltList`, `floatField -q -v \\\""+("pt_"+$name+"_reFrameSpringField")+"\\\"`, \\\"Frame\\\")\") (\"pt_"+$name+"_reFrameSpringButton\")");
					floatSliderGrp -cw3 35 45 80 -cat 1 "right" 3 -adj 3 -f 1 -l "Frame" -h 19 -pre 3 -v 1 -min 0.001 -max 10 -fmx 2000 -cc ("pt_reSpringStrength(`textScrollList -q -si pt_pelt_groupList`, `floatSliderGrp -q -v \""+("pt_"+$name+"_reFrameSpringField")+"\"`, \"Frame\")") ("pt_"+$name+"_reFrameSpringField");
					separator -style $sStyle ("pt_pelt_"+$name+"_separator2");
					// eval($iconTextButton+" -h 19 -bgc .57 .62 .65 -ann \"Re-calculate mesh strength\"  -st \"textOnly\" -l \"Re-mesh Strength\" -c (\"pt_reSpringStrength(`textScrollList -q -si pt_pelt_groupList`, `textScrollList -q -ai pt_peltList`, `floatField -q -v \\\""+("pt_"+$name+"_reMeshSpringField")+"\\\"`, \\\"Mesh\\\")\") (\"pt_"+$name+"_reMeshSpringButton\")");
					separator -style $sStyle ("pt_pelt_"+$name+"_separator3");
					floatSliderGrp -cw3 35 45 80 -cat 1 "right" 3 -adj 3 -f 1 -l "Mesh" -h 19 -pre 3 -v 1 -min 0.001 -max 2 -fmx 200 -cc ("pt_reSpringStrength(`textScrollList -q -si pt_pelt_groupList`, `floatSliderGrp -q -v \""+("pt_"+$name+"_reMeshSpringField")+"\"`, \"Mesh\")")("pt_"+$name+"_reMeshSpringField");
					separator -style $sStyle ("pt_pelt_"+$name+"_separator4");
					frameLayout -cll 1 -cl 1 -lv 0 -bv 0 ("pt_"+$name+"_extraFrame");
						floatSliderGrp -cw3 35 45 80 -cat 1 "right" 3 -adj 3 -f 1 -l "Extra" -h 19 -pre 3 -v 1 -min 0.000 -max 2 -fmx 200 -cc ("pt_reSpringStrength(`textScrollList -q -si pt_pelt_groupList`, `floatSliderGrp -q -v \""+("pt_"+$name+"_reExtraSpringField")+"\"`, \"Extra\")")("pt_"+$name+"_reExtraSpringField");
					setParent ..;
					text -h 19 -l "Runtime Velocity " -ann "Control values below while sim is runnning" -al "right" -fn "plainLabelFont" ("pt_"+$name+"_conserveText");
					text -h 19 -l " (CTRL+MMB drag)" -al "left" ("pt_"+$name+"_dragText");
					floatField -bgc 0.5 0.5 0.5 -h 22 -max 1 -min 0 -pre 3 -s .0001 -v .999 ("pt_"+$name+"_dampField");
					
					separator -style $sStyle ("pt_pelt_"+$name+"_separator1");
					
					
					// eval($iconTextButton+" -h 19 -bgc .67 .72 .75  -st \"textOnly\" -l \"REMOVE PELT FROM SIM\"  -c (\"pt_removeSimPelt(`textScrollList -q -si pt_pelt_groupList`);currentTime -e (`playbackOptions -q -ast`);\") pt_removePeltButton");
					eval($iconTextButton+" -ann \"Removes the pelt from the simulation\" -h 19 -bgc .67 .72 .75  -st \"textOnly\" -l \"REMOVE PELT FROM SIM\"  -c (\"pt_removeSimPelt(pt_returnFirstItemInList(`textScrollList -q -si pt_pelt_groupList`),0);currentTime -e (`playbackOptions -q -ast`);\") pt_removePeltButton");
					separator -style $sStyle ("pt_pelt_"+$name+"_separator5");
					eval($iconTextCheckBox+" -ann \"Locks the simulation at the current frame\" -h 19 -bgc .57 .62 .65  -st \"textOnly\" -l \"LOCK PELT\"  -onc (\"pt_lockSimPelt(`textScrollList -q -si pt_pelt_groupList`,1,\\\"pt_lockPeltButton\\\")\") -ofc (\"pt_lockSimPelt(`textScrollList -q -si pt_pelt_groupList`,0,\\\"pt_lockPeltButton\\\")\") pt_lockPeltButton");
					formLayout -e
						-af ("pt_peltList") "top" 0
						-af ("pt_peltList") "right" 0
						-af ("pt_peltList") "left" 0

						-ac ("pt_"+$name+"_addSpringBox") "top" 0 ("pt_peltList")
						-af ("pt_"+$name+"_addSpringBox") "left" 0
						-af ("pt_"+$name+"_addSpringBox") "right" 0
						
						-ac ("pt_"+$name+"_springFrame") "top" 0 ("pt_"+$name+"_addSpringBox")
						-af ("pt_"+$name+"_springFrame") "right" 0
						-af ("pt_"+$name+"_springFrame") "left" 0
						
						-ac ("pt_pelt_"+$name+"_separator6") "top" -1 ("pt_"+$name+"_springFrame")
						-af ("pt_pelt_"+$name+"_separator6") "right" 0
						-af ("pt_pelt_"+$name+"_separator6") "left" 0

						
						-ac ("pt_"+$name+"_paintButton") "top" -1 ("pt_pelt_"+$name+"_separator6")
						-af ("pt_"+$name+"_paintButton") "left" 0
						-af ("pt_"+$name+"_paintButton") "right" 0
						
						// -ac ("pt_"+$name+"_reFrameSpringButton") "top" 0 ("pt_"+$name+"_paintButton")
						// -af ("pt_"+$name+"_reFrameSpringButton") "left" 0
						// -af ("pt_"+$name+"_reFrameSpringButton") "right" 50

						-ac ("pt_pelt_"+$name+"_separator2") "top" -1 ("pt_"+$name+"_paintButton")
						-af ("pt_pelt_"+$name+"_separator2") "right" 0
						-af ("pt_pelt_"+$name+"_separator2") "left" 0

						
						-ac ("pt_"+$name+"_reFrameSpringField") "top" 0 ("pt_pelt_"+$name+"_separator2")
						-af ("pt_"+$name+"_reFrameSpringField") "left" 0
						-af ("pt_"+$name+"_reFrameSpringField") "right" 0

						
						
						-ac ("pt_pelt_"+$name+"_separator3") "top" -1 ("pt_"+$name+"_reFrameSpringField")
						-af ("pt_pelt_"+$name+"_separator3") "right" 0
						-af ("pt_pelt_"+$name+"_separator3") "left" 0
	
						-ac ("pt_"+$name+"_reMeshSpringField") "top" 0 ("pt_pelt_"+$name+"_separator3")
						-af ("pt_"+$name+"_reMeshSpringField") "left" 0
						-af ("pt_"+$name+"_reMeshSpringField") "right" 0

						-ac ("pt_"+$name+"_extraFrame") "top" 0 ("pt_"+$name+"_reMeshSpringField")
						-af ("pt_"+$name+"_extraFrame") "left" 0
						-af ("pt_"+$name+"_extraFrame") "right" 0
						
						-ac ("pt_pelt_"+$name+"_separator4") "top" -1 ("pt_"+$name+"_extraFrame")
						-af ("pt_pelt_"+$name+"_separator4") "right" 0
						-af ("pt_pelt_"+$name+"_separator4") "left" 0

						
						-ac ("pt_"+$name+"_conserveText") "top" 0 ("pt_pelt_"+$name+"_separator4")
						-af ("pt_"+$name+"_conserveText") "left" 0
						-ap ("pt_"+$name+"_conserveText") "right" 0 50
						
						-ac ("pt_"+$name+"_dragText") "top" 0 ("pt_pelt_"+$name+"_separator4")
						-ap ("pt_"+$name+"_dragText") "left" 0 50
						-af ("pt_"+$name+"_dragText") "right" 0
						
						-ac ("pt_"+$name+"_dampField") "top" 0 ("pt_"+$name+"_dragText")
						//-af ("pt_"+$name+"_dampField") "bottom" 2
						-af ("pt_"+$name+"_dampField") "right" 0
						-af ("pt_"+$name+"_dampField") "left" 0

						-ac ("pt_pelt_"+$name+"_separator1") "top" 0 ("pt_"+$name+"_dampField")
						-af ("pt_pelt_"+$name+"_separator1") "right" 0
						-af ("pt_pelt_"+$name+"_separator1") "left" 0

						-ac pt_lockPeltButton "top" -1 ("pt_pelt_"+$name+"_separator1")
						-af pt_lockPeltButton "right" 0
						-af pt_lockPeltButton "left" 0
						
						-ac ("pt_pelt_"+$name+"_separator5") "top" -1 pt_lockPeltButton
						-af ("pt_pelt_"+$name+"_separator5") "right" 0
						-af ("pt_pelt_"+$name+"_separator5") "left" 0

						
						-ac pt_removePeltButton "top" -1 ("pt_pelt_"+$name+"_separator5")
						-af pt_removePeltButton "left" 0
						-af pt_removePeltButton "right" 0
						-af pt_removePeltButton "bottom" 1
						
						
					("pt_pelt_"+$name+"Form");
				
					break;
				case "visualisation":
					text -h 19 -w 27 -al "left" -l "FILE" -fn "plainLabelFont" ("pt_"+$name+"_imageText");
					textField -h 19 ("pt_imageField");
					symbolButton -h 19 -i "OUT_FILE.xpm" -c ("pt_openTextureBrowser(`textScrollList -q -ai pt_peltList`)") ("pt_"+$name+"_imageButton");
					separator -hr 1 -style "in" ("pt_"+$name+"separator1");
	
					eval($iconTextButton+" -st \"textOnly\" -l \"Re-apply Shader\" -ann \"Reapply shader to texture mesh\" -h 19 -bgc .57 .62 .65  -c (\"pt_applyImageToDuplicate (`textField -q -tx pt_imageField`, \\\"image\\\")\") (\"pt_"+$name+"_reApplyButton\")");
					eval($iconTextButton+" -st \"iconOnly\" -ann \"Default View\" -i pelt_default.xpm -h 19 -bgc .67 .72 .75  -c (\"pt_toggleModelViews(`textScrollList -q -si pt_pelt_groupList`,\\\"none\\\")\") (\"pt_"+$name+"_imageNoneButton\")");
					eval($iconTextButton+" -st \"iconOnly\" -ann \"Checker Grid\" -i OUT_GRID.xpm -h 19 -bgc .67 .72 .75  -c (\"pt_toggleModelViews(`textScrollList -q -si pt_pelt_groupList`,\\\"checker\\\")\") (\"pt_"+$name+"_imageCheckerButton\")");
					eval($iconTextButton+" -st \"iconOnly\" -ann \"Baked Normals\" -i pelt_normals.xpm -h 19 -bgc .67 .72 .75  -c (\"pt_toggleModelViews(`textScrollList -q -si pt_pelt_groupList`,\\\"normals\\\")\") (\"pt_"+$name+"_imageBakedButton\")");
					
					separator -hr 0 -style "in" ("pt_"+$name+"separator2");
					separator -hr 0 -style "double" ("pt_"+$name+"separator3");
					separator -hr 0 -style "double" ("pt_"+$name+"separator4");
					
					
					
					text -h 19 -w 68 -l "Repeat UV" -fn "plainLabelFont" -al "center" ("pt_"+$name+"_uText");
					floatField -w 23 -h 19 -pre 1 -s 1 -min 0.001 -v 2 ("pt_"+$name+"_uField");
					// text -h 19 -w 68 -l "V" -fn "plainLabelFont" -al "center" ("pt_"+$name+"_vText");
					floatField -w 23 -h 19 -pre 1 -s 1 -min 0.001 -v 2 ("pt_"+$name+"_vField");
					
					
					formLayout -e
						-af ("pt_"+$name+"_imageText") "left" 5
						
						-af ("pt_imageField") "left" 30
						-af ("pt_imageField") "right" 30
					
						-af ("pt_"+$name+"_imageButton") "right" 0
						-ac ("pt_"+$name+"_imageButton") "left" 0 ("pt_imageField")

						-ac ("pt_"+$name+"separator1") "top" 0 ("pt_imageField")
						-af ("pt_"+$name+"separator1") "right" 0
						-af ("pt_"+$name+"separator1") "left" 0

						-af ("pt_"+$name+"_reApplyButton") "left" 0
						-af ("pt_"+$name+"_reApplyButton") "right" 0
						-ac ("pt_"+$name+"_reApplyButton") "top" 0 ("pt_"+$name+"separator1")

						-ac ("pt_"+$name+"_imageCheckerButton") "top" 0 ("pt_"+$name+"_reApplyButton")
						-af ("pt_"+$name+"_imageCheckerButton") "left" 0
						-ap ("pt_"+$name+"_imageCheckerButton") "right" 0 17

						-ac ("pt_"+$name+"separator3") "top" 0 ("pt_"+$name+"_reApplyButton")
						-ac ("pt_"+$name+"separator3") "left" 0 ("pt_"+$name+"_imageCheckerButton")
						-af ("pt_"+$name+"separator3") "bottom" 1

						-ac ("pt_"+$name+"separator4") "top" 0 ("pt_"+$name+"_reApplyButton")
						-ac ("pt_"+$name+"separator4") "left" 1 ("pt_"+$name+"separator3")
						-af ("pt_"+$name+"separator4") "bottom" 1

						
						-ac ("pt_"+$name+"_imageNoneButton") "left" 8 ("pt_"+$name+"_imageCheckerButton")
						-ac ("pt_"+$name+"_imageNoneButton") "top" 0 ("pt_"+$name+"_reApplyButton")
						-ac ("pt_"+$name+"_imageNoneButton") "right" 1 ("pt_"+$name+"_imageBakedButton")

						
						-ac ("pt_"+$name+"separator2") "top" 0 ("pt_"+$name+"_reApplyButton")
						-ac ("pt_"+$name+"separator2") "left" -1 ("pt_"+$name+"_imageNoneButton")
						-af ("pt_"+$name+"separator2") "bottom" 1
						
						-ac ("pt_"+$name+"_imageBakedButton") "top" 0 ("pt_"+$name+"_reApplyButton")
						-ap ("pt_"+$name+"_imageBakedButton") "right" 0 50
						-ap ("pt_"+$name+"_imageBakedButton") "left" 0 35
						
						-ac ("pt_"+$name+"_uText") "top" 0 ("pt_"+$name+"_reApplyButton")
						-ac ("pt_"+$name+"_uText") "left" 0 ("pt_"+$name+"_imageBakedButton")
						-af ("pt_"+$name+"_uText") "right" 50
						
						-ac ("pt_"+$name+"_uField") "top" 0 ("pt_"+$name+"_reApplyButton")
						-af ("pt_"+$name+"_uField") "right" 25
						-ac ("pt_"+$name+"_uField") "left" 0 ("pt_"+$name+"_uText")
						
						-ac ("pt_"+$name+"_vField") "top" 0 ("pt_"+$name+"_reApplyButton")
						-af ("pt_"+$name+"_vField") "right" 0
						-ac ("pt_"+$name+"_vField") "left" 0 ("pt_"+$name+"_uField")
						
						
					("pt_pelt_"+$name+"Form");
					
					break;
				case "shell":
					$sStyle = "in";
					text -h 19 -l "Move" ("pt_"+$name+"_moveText");
					floatField -ann "Moves UV points in U" -ec ("pt_moveUV(`ls -sl -fl`, `floatField -q -v \""+("pt_"+$name+"_uMoveField")+"\"`, \"u\",\""+"pt_"+$name+"\")") ("pt_"+$name+"_uMoveField");
					floatField -ann "Moves UV points in V" -ec ("pt_moveUV(`ls -sl -fl`, `floatField -q -v \""+("pt_"+$name+"_vMoveField")+"\"`, \"v\",\""+"pt_"+$name+"\")") ("pt_"+$name+"_vMoveField");
					separator -st $sStyle ("pt_"+$name+"_separator1");
					eval($iconTextButton+" -h 19 -bgc .57 .62 .65  -ann \"Normalize UV into their current range\" -st \"textOnly\" -l \"Normalize UV (normal)\"  -c (\"pt_normalizeUV(`ls -sl`,\\\"\\\")\") "+("pt_"+$name+"_normalizeButton")+"");
					popupMenu;
						menuItem -rb 1 -l "normal scale (0 - 1)" -c ("iconTextButton -e -l \"Normalize UV (normal)\" -c (\"pt_normalizeUV(`ls -sl`,\\\"normal\\\")\") "+("pt_"+$name+"_normalizeButton")+"");
						menuItem -rb 0 -l "smaller scale (0.11 - 0.99)" -c ("iconTextButton -e -l \"Normalize UV (smaller)\" -c (\"pt_normalizeUV(`ls -sl`,\\\"smaller\\\")\") "+("pt_"+$name+"_normalizeButton")+"");
						
					eval($iconTextButton+" -h 19 -bgc .67 .72 .75  -ann \"Select UV Shell From Components\" -st \"textOnly\" -l \"Select UV Shell\"  -c (\"select (`polyListComponentConversion -fv -fe -ff -fuv -tuv`);polySelectConstraint -sh 1 -m 2;resetPolySelectConstraint;\") "+("pt_"+$name+"_shellBorderButton")+"");
					separator -st $sStyle ("pt_"+$name+"_separator2");
					text -h 19 -l "Scale" ("pt_"+$name+"_scaleText");
					floatField -ann "Scales UV points in U and V" -v 1 -ec ("pt_scaleUV(`ls -sl -fl`, `floatField -q -v \""+("pt_"+$name+"_uScaleField")+"\"`, \"u\",\""+"pt_"+$name+"\")") ("pt_"+$name+"_uScaleField");
					floatField -en 0 -ann "Scales UV points in V" -v 1 -ec ("pt_scaleUV(`ls -sl -fl`, `floatField -q -v \""+("pt_"+$name+"_vScaleField")+"\"`, \"v\",\""+"pt_"+$name+"\")") ("pt_"+$name+"_vScaleField");
					checkBox -h 22 -ann "Unlocks Scale in V"  -l "" -onc ("floatField -e -en 1 "+("pt_"+$name+"_vScaleField")+";floatField -e -ann "+("\"Scales UV points in U\"")+" "+("pt_"+$name+"_uScaleField")+"") -ofc ("floatField -e -en 0 "+("pt_"+$name+"_vScaleField")+";floatField -e -ann "+("\"Scales UV points in U and V\"")+" "+("pt_"+$name+"_uScaleField")+"") ("pt_"+$name+"_lockScaleBox");
				
					formLayout -e 
						-af ("pt_"+$name+"_moveText") "left" 0
						
						-af ("pt_"+$name+"_uMoveField") "left" 35
						-ap ("pt_"+$name+"_uMoveField") "right" -18 50
				
						-ap ("pt_"+$name+"_vMoveField") "left" 16 50
						-af ("pt_"+$name+"_vMoveField") "right" 0 
				
						-af ("pt_"+$name+"_separator1") "left" 0
						-af ("pt_"+$name+"_separator1") "right" 0
						-ac ("pt_"+$name+"_separator1") "top" -1 ("pt_"+$name+"_vMoveField")
						
						-af ("pt_"+$name+"_scaleText") "left" 0
						-ac ("pt_"+$name+"_scaleText") "top" 0 ("pt_"+$name+"_separator1")
						
						-ac ("pt_"+$name+"_uScaleField") "top" 0 ("pt_"+$name+"_separator1")
						-af ("pt_"+$name+"_uScaleField") "left" 35
						-ap ("pt_"+$name+"_uScaleField") "right" -18 50
				
						-ac ("pt_"+$name+"_vScaleField") "top" 0 ("pt_"+$name+"_separator1")
						-ap ("pt_"+$name+"_vScaleField") "left" 16 50
						-af ("pt_"+$name+"_vScaleField") "right" 19

						-af ("pt_"+$name+"_lockScaleBox") "right" 0
						-ac ("pt_"+$name+"_lockScaleBox") "top" 0 ("pt_"+$name+"_separator1")
						-ac ("pt_"+$name+"_lockScaleBox") "left" 3 ("pt_"+$name+"_vScaleField")
						
						-af ("pt_"+$name+"_separator2") "left" 0
						-af ("pt_"+$name+"_separator2") "right" 0
						-ac ("pt_"+$name+"_separator2") "top" -1 ("pt_"+$name+"_vScaleField")
					
						-ac ("pt_"+$name+"_normalizeButton") "top" 0 ("pt_"+$name+"_separator2")
						-af ("pt_"+$name+"_normalizeButton") "left" 0
						-af ("pt_"+$name+"_normalizeButton") "right" 0
						
						-ac ("pt_"+$name+"_shellBorderButton") "top" 0 ("pt_"+$name+"_normalizeButton")
						-af ("pt_"+$name+"_shellBorderButton") "right" 0
						-af ("pt_"+$name+"_shellBorderButton") "left" 0
						-af ("pt_"+$name+"_shellBorderButton") "bottom" 1
					("pt_pelt_"+$name+"Form");
					break;
				}
				
			formLayout -e 
				-af ("pt_pelt_"+$name+"Separator2") "bottom" 0
				-af ("pt_pelt_"+$name+"Separator2") "right" 0
				-af ("pt_pelt_"+$name+"Separator2") "left" 0
			("pt_pelt_"+$name+"Form");		
		
			setParent;
		setParent;
	setParent $parent;
}


global proc pt_drawUVControls()
{
	string $pclm;
	formLayout -p pt_TabLayout pt_uv_mainForm;
		formLayout  pt_uv_controlsForm;
			$pclm = `columnLayout -en 1 -adj 1 pt_uv_columnLayout1`;
			pt_pelt_createFrameLayout($pclm,"shell", "Shell Editing",0);
			pt_pelt_createFrameLayout($pclm,"tweak", "UV Tweak",0);
		setParent ..;
	setParent ..;
	
	formLayout -e 		
		-af pt_uv_controlsForm "top" 0
		-af pt_uv_controlsForm "left" 0
		-af pt_uv_controlsForm "right" 0
		-af pt_uv_controlsForm "bottom" 0
	pt_uv_mainForm;
	
	formLayout -e 
		-af $pclm "right" 0
		-af $pclm "left" 0
	pt_uv_controlsForm;
}

global proc pt_drawPeltingControls_Proc()
{
	string $pclm;
	string $pclm2;
	string $name;
	
	if (pt_returnMayaVersion() == "6.0")
		$iconTextButton = "iconTextButton";
	else
		$iconTextButton = "iconTextButton -fn \"smallFixedWidthFont\"";

	formLayout pt_pelt_mainForm;	
		formLayout pt_pelt_controlsForm;
			$pclm = `columnLayout -adj 1 pt_pelt_columnLayout`;
/* 				menuBarLayout;
					menu -label "Tools";
						menuItem -l "General Edge Tools" -sm 1 -to 1;
							menuItem -l "Cut" -c ("pt_cutEdges(\"\");");
							menuItem -l "Merge" -c ("pt_mergeEdges()");
							menuItem -l "Loop" -c ("pt_selectLoop()");
							setParent -menu ..;
						menuItem -l "Separate Shells" -c ("selectMode -o;polySeparate;polyOptions -r -db true");
						menuItem -d 1;
						menuItem -ann "Select Objects and Merge Edges/Polys" - l "Merge All Overlapping Borders" -c ("pt_merge_overlapBorderEdges");
						menuItem -d 1;
						menuItem -sm 1 -l "Transfer Tools";
							menuItem -ann "Cut Mesh at UV Seams" -l "Cut Mesh at UV Seams" -c ("pt_cutMeshAtSeams(`ls -sl -fl`)");
							menuItem -d 1;
							menuItem -ann "Transfer UVS: Source to Target" -l "Brute Force Transfer UVs: Source -> Target" -c ("pt_transferUVS()");
							setParent -menu ..;
						menuItem -l "UV Tools" -c ("pt_uvTools()");
					menu -pmc ("pt_preMenuOptionsCmd()") -label "Options"; 
						menuItem -cb 1 -label "Toggle Global Vertex Coloring" -c ("pt_toggleGlobalVertexColors(`menuItem -q -cb pt_toggleColorMenu`)") ("pt_toggleColorMenu");
						menuItem -cb 1 -label "Show Dynamics" -c ("pt_toggleShowDynamics(`menuItem -q -cb pt_showDynamicsMenu`)") ("pt_showDynamicsMenu");
					menu -label "Help";
						menuItem -l "visit peltingTools website..." -c ("pt_visitWebSite()");
						menuItem -l "show file header..." -c ("pt_displayHelpText(\"peltingTools.mel\")");
						menuItem -l "about..." -c ("pt_aboutWindow()");
						
				setParent ..;
 */				
				//	GENERAL CONTROLS
				//
				$name = "general";
				separator -style "single";
				formLayout ("pt_pelt_"+$name+"OriginalForm");
					eval($iconTextButton+" -h 19 -bgc .67 .72 .75 -ann \"Select Original Mesh\" -st \"textOnly\" -l \"<-Original\"  -c (\"pt_enterOriginalMesh(`ls -sl -fl`, `textScrollList -q -si pt_pelt_groupList`)\") (\"pt_"+$name+"_originalButton\")");
					textScrollList -nr 1 -h 19 -ann "Click to Select Object" -sc ("select (pt_returnFirstItemInList(`textScrollList -q -si (\"pt_"+$name+"_originalField\")`));textScrollList -e -da (\"pt_"+$name+"_originalField\");") ("pt_"+$name+"_originalField");
				setParent ..;
				separator -style "single";
				formLayout -e
					-af ("pt_"+$name+"_originalField") "left" 0
					-af ("pt_"+$name+"_originalField") "right" 80
					
					-af ("pt_"+$name+"_originalButton") "right" 0
					-ac ("pt_"+$name+"_originalButton") "left" 0 ("pt_"+$name+"_originalField")
				("pt_pelt_"+$name+"OriginalForm");
				pt_pelt_createFrameLayout($pclm,"groups", "PELT GROUPS",1);

				
				$pclm2 = `columnLayout -en 0 -adj 1 pt_pelt_columnLayout2`;
					pt_pelt_createFrameLayout($pclm2,"cutting", "Cut Tools",1);
					pt_pelt_createFrameLayout($pclm2,"parts", "Part Components",0);
					pt_pelt_createFrameLayout($pclm2,"edge", "Edge Tools",0);
					pt_pelt_createFrameLayout($pclm2,"pelt", "Pelt Tools",0);
					pt_pelt_createFrameLayout($pclm2,"simulation", "Simulation Tools",0);
					pt_pelt_createFrameLayout($pclm2,"visualisation", "Visualisation Tools",0);

					setParent ..;
				
					
/* 				$name = "utilities";
				formLayout ("pt_pelt_"+$name+"Form");
					// iconTextButton -h 19 -bgc .85 .85 .95 -ann "Display Edge Borders" -st "textOnly" -l "Display"  -c ("polyOptions -r -db true") ("pt_"+$name+"_borderButton");
					iconTextButton -h 19 -bgc .75 .75 .85  -ann "General: Select Shell From Components" -st "textOnly" -l "Select Shell"  -c ("polySelectConstraint -sh 1 -m 2 -type 0x0000;resetPolySelectConstraint;") ("pt_"+$name+"_shellBorderButton");
					iconTextButton -h 19 -bgc .2 .3 .4  -ann "Toggles vertex coloring" -st "textOnly" -l "Edge Color"  -c ("pt_toggleVertexColors(`textScrollList -q -si pt_pelt_groupList`)") ("pt_"+$name+"_colorButton");				
				setParent ..;
				
				formLayout -e
					// -af ("pt_"+$name+"_borderButton") "left" 0
					// -ap ("pt_"+$name+"_borderButton") "right" 0 33
					
					-ap ("pt_"+$name+"_shellBorderButton") "right" 0 50
					-af ("pt_"+$name+"_shellBorderButton") "left" 0
					
					-af ("pt_"+$name+"_colorButton") "right" 0
					-ap ("pt_"+$name+"_colorButton") "left" 0 50
					
				("pt_pelt_"+$name+"Form");
 */				
		setParent ..;
	setParent ..;
	
	
	formLayout -e 		
		-af pt_pelt_controlsForm "top" 0
		-af pt_pelt_controlsForm "left" 0
		-af pt_pelt_controlsForm "right" 0
		-af pt_pelt_controlsForm "bottom" 0
	pt_pelt_mainForm;
	
	formLayout -e 
		-af $pclm "right" 0
		-af $pclm "left" 0
		
	pt_pelt_controlsForm;
}


//MAIN WINDOW
global proc peltingTools()
{
	if (`window -ex peltingTools`)
		deleteUI -wnd peltingTools;
	window peltingTools;
	
	if (pt_returnMayaVersion() == "6.0")
		$iconTextButton = "iconTextButton";
	else
		$iconTextButton = "iconTextButton -fn \"smallFixedWidthFont\"";

		columnLayout -adj 3 pt_columnLayout;
		menuBarLayout;
			menu -label "Tools";
				menuItem -l "General Edge Tools" -sm 1 -to 1;
					menuItem -d 1;
					menuItem -l "Cut" -c ("pt_cutEdges(\"\");");
					menuItem -l "Merge" -c ("pt_mergeEdges()");
					menuItem -l "Loop" -c ("pt_selectLoop()");
					menuItem -d 1;
					menuItem -l "Select Edge Border" -c ("polySelectConstraint -w 1 -m 2;resetPolySelectConstraint;");
					setParent -menu ..;
				menuItem -l "Separate Shells" -c ("selectMode -o;polySeparate;polyOptions -r -db true");
				menuItem -d 1;
				menuItem -ann "Select Objects and Merge Edges/Polys" - l "Merge All Overlapping Borders" -c ("pt_merge_overlapBorderEdges");
				menuItem -d 1;
				menuItem -sm 1 -l "Transfer Tools";
					menuItem -ann "Cut Mesh at UV Seams" -l "Cut Mesh at UV Seams" -c ("pt_cutMeshAtSeams(`ls -sl -fl`)");
					menuItem -d 1;
					menuItem -ann "Transfer UVS: Source to Target" -l "Brute Force Transfer UVs: Source -> Target" -c ("pt_transferUVS()");
					setParent -menu ..;
				menuItem -d 1;
				menuItem -sm 1 -l "Locked Node Tools";
					menuItem -l "Delete History" -c ("pt_setLockedNode(\"delete -ch "+(pt_returnFirstItemInList(`ls -sl`))+"\",\""+(pt_returnFirstItemInList(`ls -sl`))+"\")");
					setParent -menu ..;
				menuItem -d 1;
				menuItem -l "Script Commands" -c ("pt_scriptCmdsWindow();") ("pt_scriptMenuItem");
				// menuItem -l "UV Tools" -c ("pt_uvTools()");
			menu -pmc ("pt_preMenuOptionsCmd()") -label "Options"; 
				menuItem -cb 1 -label "Toggle Global Vertex Coloring" -c ("pt_toggleGlobalVertexColors(`menuItem -q -cb pt_toggleColorMenu`)") ("pt_toggleColorMenu");
				menuItem -cb 1 -label "Show Dynamics" -c ("pt_toggleShowDynamics(`menuItem -q -cb pt_showDynamicsMenu`)") ("pt_showDynamicsMenu");
			menu -label "Help";
				menuItem -l "visit peltingTools website..." -c ("pt_visitWebSite()");
				menuItem -l "show file header..." -c ("pt_displayHelpText(\"peltingTools.mel\")");
				menuItem -l "about..." -c ("pt_aboutWindow()");
				
		setParent ..;		
	
		tabLayout -cc ("pt_resizeWindow()") -psc ("pt_resizeWindow()") -sc ("pt_resizeWindow()") -p pt_columnLayout -imh 0 -imw 0 pt_TabLayout;
			pt_drawPeltingControls_Proc();
			pt_drawUVControls();
		
		tabLayout -e -tli 1 "Pelting" pt_TabLayout;
		tabLayout -e -tli 2 "UV Tools" pt_TabLayout;
		
		$name = "utilities";
		formLayout -p pt_columnLayout ("pt_pelt_"+$name+"Form");
			// iconTextButton -h 19 -bgc .85 .85 .95 -ann "Display Edge Borders" -st "textOnly" -l "Display"  -c ("polyOptions -r -db true") ("pt_"+$name+"_borderButton");
			iconTextButton -h 19 -bgc .75 .75 .85  -ann "General: Select Shell From Components" -st "textOnly" -l "Select Shell"  -c ("polySelectConstraint -sh 1 -m 2 -type 0x0000;resetPolySelectConstraint;") ("pt_"+$name+"_shellBorderButton");
			iconTextButton -h 19 -bgc .2 .3 .4  -ann "Toggles vertex coloring" -st "textOnly" -l "Edge Color"  -c ("pt_toggleVertexColors(`textScrollList -q -si pt_pelt_groupList`)") ("pt_"+$name+"_colorButton");				
		setParent ..;
		
		formLayout -e
			// -af ("pt_"+$name+"_borderButton") "left" 0
			// -ap ("pt_"+$name+"_borderButton") "right" 0 33
			
			-ap ("pt_"+$name+"_shellBorderButton") "right" 0 50
			-af ("pt_"+$name+"_shellBorderButton") "left" 0
			
			-af ("pt_"+$name+"_colorButton") "right" 0
			-ap ("pt_"+$name+"_colorButton") "left" 0 50
			
		("pt_pelt_"+$name+"Form");
		setParent ..;
/* 		$name = "script";
		frameLayout -lv 0 -cl 0 -bv 1 -bs "in" -cll 1 -m 1 -p pt_columnLayout ("pt_pelt_"+$name+"Frame");
			formLayout ("pt_pelt_"+$name+"Form");
				textField -ann "Click on CMDS to get list of acceptable cmds" ("pt_pelt_"+$name+"Field");
				eval($iconTextButton+" -h 21 -bgc .67 .72 .75 -ann \"Select to get list of commands\" -st \"textOnly\" -l \"cmds>\"  -c (\"\") "+("pt_"+$name+"_cmdsButton")+"");
				popupMenu -b 1;
					menuItem -l "Insert from Below";
					menuItem -d 1;
					// menuItem -l "*bypass";
					// menuItem -l "*requires (0=no pelt group, 1=pelt group)";
					menuItem -ann "uses start of time range" -l "*time (0=start, 1=currentTime)" -c ("pt_appendToCmd(\"time\")");
					menuItem -l "*play" -c ("pt_appendToCmd(\"play\")");;
					menuItem -l "*stop" -c ("pt_appendToCmd(\"stop\")");;
					menuItem -ann "cuts selected edges" -l "*cut (requires edge selection)" -c ("pt_appendToCmd(\"cut\")");;
					menuItem -ann "merges selected edges" -l "*merge (requires edge selection)" -c ("pt_appendToCmd(\"merge\")");;
					menuItem -l "*continuous" -c ("pt_appendToCmd(\"continuous\")");;
					menuItem -l "*frame (xy, xz, yz)" -c ("pt_appendToCmd(\"frame\")");;
					menuItem -l "*pelt (world, even)" -c ("pt_appendToCmd(\"pelt\")");;
					menuItem -l "*deletePelt" -c ("pt_appendToCmd(\"deletePelt\")");;
					menuItem -l "*removePelt" -c ("pt_appendToCmd(\"removePelt\")");;

					
					
					
					
					
				separator ("pt_"+$name+"_separator1");
				eval($iconTextButton+" -h 19 -bgc .57 .62 .65 -ann \"Executes above commands\" -st \"textOnly\" -l \"EXECUTE CMD\"  -c (\"eval(pt_generateScriptedCmd(`textField -q -tx "+("pt_pelt_"+$name+"Field")+"`,\\\"cmd\\\"))\") "+("pt_"+$name+"_executeButton")+"");
				eval($iconTextButton+" -h 19 -bgc .47 .52 .55 -ann \"Generates script from above commands\" -st \"textOnly\" -l \"GENERATE CMD\"  -c (\"pt_generateScriptedCmd(`textField -q -tx "+("pt_pelt_"+$name+"Field")+"`,\\\"script\\\")\") "+("pt_"+$name+"_generateButton")+"");
				// iconTextButton;
			setParent ..;
		setParent ..;
		formLayout -e 
			-af ("pt_pelt_"+$name+"Field") "left" 0
			-af ("pt_pelt_"+$name+"Field") "right" 42
			
			-ac ("pt_"+$name+"_cmdsButton") "left" 0 ("pt_pelt_"+$name+"Field")
			-af ("pt_"+$name+"_cmdsButton") "right" 0
			
			-ac ("pt_"+$name+"_separator1") "top" -1 ("pt_"+$name+"_cmdsButton")
			-af ("pt_"+$name+"_separator1") "left" 0
			-af ("pt_"+$name+"_separator1") "right" 0
			
			-ap ("pt_"+$name+"_executeButton") "right" 0 50
			-af ("pt_"+$name+"_executeButton") "left" 0
			-ac ("pt_"+$name+"_executeButton") "top" -1 ("pt_"+$name+"_separator1")
			
			-ac ("pt_"+$name+"_generateButton") "top" -1 ("pt_"+$name+"_separator1")
			-ap ("pt_"+$name+"_generateButton") "left" 0 50
			-af ("pt_"+$name+"_generateButton") "right" 0
			
			
			
		("pt_pelt_"+$name+"Form");
 */		
	setParent ..;
	showWindow peltingTools;
	window -e -w 236 peltingTools;
	
	pt_populateGroupsList();
	pt_createScriptJob();
	pt_resizeWindow;
	columnLayout -e -en 0 pt_pelt_columnLayout2;
}


pt_pluginQuery();

